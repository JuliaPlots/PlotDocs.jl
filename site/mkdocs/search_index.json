{
    "docs": [
        {
            "location": "/",
            "text": "Intro to Plots in Julia\n\n\nAuthor: Thomas Breloff (@tbreloff)\n\n\nData visualization has a complicated history, with plotting software making trade-offs between features vs simplicity, speed vs beauty, and static vs dynamic.  Some make a visualization and never change it, others must make updates in real-time.\n\n\nPlots is a visualization interface and toolset.  It sits above other visualization \"backends\", connecting commands with implementation.  If one backend does not support your desired features, or make the right trade-offs, just switch to another backend with one command.  No need to change your code.  No need to learn something new.  Plots might be the last plotting package you ever learn.\n\n\nMy goals with the package are:\n\n\n\n\nPowerful\n.  Do more with less.  Complex visualizations become easy.\n\n\nIntuitive\n.  Start generating plots without reading volumes of documentation.  Commands should \"just work\".\n\n\nConcise\n.  Less code means fewer mistakes and more efficient development/analysis.\n\n\nFlexible\n.  Produce your favorite plots from your favorite package, but quicker and simpler.\n\n\nConsistent\n.  Don't commit to one graphics package.  Use the same code and access the strengths of all \nbackends\n.\n\n\nLightweight\n.  Very few dependencies, since backends are loaded and initialized dynamically.\n\n\nSmart\n.  It's not quite AGI, but Plots should figure out what you \nwant\n it to do... not just what you \ntell\n it.\n\n\n\n\nUse the \npreprocessing pipeline\n in Plots to fully describe your visualization before it calls the backend code.  This maintains modularity and allows for efficient separation of front end code, algorithms, and backend graphics.\n\n\nTap into the extensive visualization functionality enabled by the \nPlots ecosystem\n, and easily build your own complex graphics components with \nrecipes\n.\n\n\nPlease add wishlist items, bugs, or any other comments/questions to the \nissues list\n, and \njoin the conversation on gitter\n.\n\n\n\n\nSimple is Beautiful\n\n\nLorenz Attractor\n\n\n# initialize the attractor\n\n\nn\n \n=\n \n1500\n\n\ndt\n \n=\n \n0.02\n\n\n\u03c3\n,\n \n\u03c1\n,\n \n\u03b2\n \n=\n \n10.\n,\n \n28.\n,\n \n8\n/\n3\n\n\nx\n,\n \ny\n,\n \nz\n \n=\n \n1.\n,\n \n1.\n,\n \n1.\n\n\n\n# initialize a 3D plot with 1 empty series\n\n\nplt\n \n=\n \npath3d\n(\n1\n,\n \nxlim\n=\n(\n-\n25\n,\n25\n),\n \nylim\n=\n(\n-\n25\n,\n25\n),\n \nzlim\n=\n(\n0\n,\n50\n),\n\n                \nxlab\n \n=\n \n\"x\"\n,\n \nylab\n \n=\n \n\"y\"\n,\n \nzlab\n \n=\n \n\"z\"\n,\n\n                \ntitle\n \n=\n \n\"Lorenz Attractor\"\n,\n \nmarker\n \n=\n \n1\n)\n\n\n\n# build an animated gif, saving every 10th frame\n\n\n@gif\n \nfor\n \ni\n=\n1\n:\nn\n\n    \ndx\n \n=\n \n\u03c3\n*\n(\ny\n \n-\n \nx\n)\n     \n;\n \nx\n \n+=\n \ndt\n \n*\n \ndx\n\n    \ndy\n \n=\n \nx\n*\n(\n\u03c1\n \n-\n \nz\n)\n \n-\n \ny\n \n;\n \ny\n \n+=\n \ndt\n \n*\n \ndy\n\n    \ndz\n \n=\n \nx\n*\ny\n \n-\n \n\u03b2\n*\nz\n     \n;\n \nz\n \n+=\n \ndt\n \n*\n \ndz\n\n    \npush!\n(\nplt\n,\n \nx\n,\n \ny\n,\n \nz\n)\n\n\nend\n \nevery\n \n10\n\n\n\n\n\n\n\n\nMake some waves\n\n\nusing\n \nPlots\n\n\npyplot\n(\nleg\n=\nfalse\n,\n \nticks\n=\nnothing\n)\n\n\nx\n \n=\n \ny\n \n=\n \nlinspace\n(\n-\n5\n,\n \n5\n,\n \n40\n)\n\n\nzs\n \n=\n \nzeros\n(\n0\n,\n40\n)\n\n\n\n@gif\n \nfor\n \ni\n \nin\n \nlinspace\n(\n0\n,\n \n2\n\u03c0\n,\n \n100\n)\n\n    \nf\n(\nx\n,\ny\n)\n \n=\n \nsin\n(\nx\n \n+\n \n10\nsin\n(\ni\n))\n \n+\n \ncos\n(\ny\n)\n\n\n    \n# create a plot with 3 subplots and a custom layout\n\n    \nl\n \n=\n \n@layout\n \n[\na\n{\n0.7\nw\n}\n \nb\n;\n \nc\n{\n0.2\nh\n}]\n\n    \np\n \n=\n \nplot\n(\nx\n,\n \ny\n,\n \nf\n,\n \nst\n \n=\n \n[\n:\nsurface\n,\n \n:\ncontourf\n],\n \nlayout\n=\nl\n)\n\n\n    \n# add a tracking line\n\n    \nfixed_x\n \n=\n \nzeros\n(\n40\n)\n\n    \nz\n \n=\n \nmap\n(\nf\n,\nfixed_x\n,\ny\n)\n\n    \nplot!\n(\np\n[\n1\n],\n \nfixed_x\n,\n \ny\n,\n \nz\n,\n \nline\n \n=\n \n(\n:\nblack\n,\n \n5\n,\n \n0.2\n))\n\n    \nvline!\n(\np\n[\n2\n],\n \n[\n0\n],\n \nline\n \n=\n \n(\n:\nblack\n,\n \n5\n))\n\n\n    \n# add to and show the tracked values over time\n\n    \nzs\n \n=\n \nvcat\n(\nzs\n,\n \nz\n'\n)\n\n    \nplot!\n(\np\n[\n3\n],\n \nzs\n,\n \nalpha\n \n=\n \n0.2\n,\n \npalette\n \n=\n \ncgrad\n(\n:\nblues\n)\n.\ncolors\n)\n\n\nend\n\n\n\n\n\n\n\n\nIris Dataset\n\n\n# load a dataset\n\n\nusing\n \nRDatasets\n\n\niris\n \n=\n \ndataset\n(\n\"datasets\"\n,\n \n\"iris\"\n);\n\n\n\n# load the StatPlots recipes (for DataFrames) available via:\n\n\n# Pkg.add(\"StatPlots\")\n\n\nusing\n \nStatPlots\n\n\n\n# Scatter plot with some custom settings\n\n\nscatter\n(\niris\n,\n \n:\nSepalLength\n,\n \n:\nSepalWidth\n,\n \ngroup\n=:\nSpecies\n,\n\n        \ntitle\n \n=\n \n\"My awesome plot\"\n,\n\n        \nxlabel\n \n=\n \n\"Length\"\n,\n \nylabel\n \n=\n \n\"Width\"\n,\n\n        \nm\n=\n(\n0.5\n,\n \n[\n:\ncross\n \n:\nhex\n \n:\nstar7\n],\n \n12\n),\n\n        \nbg\n=\nRGB\n(\n.\n2\n,\n.\n2\n,\n.\n2\n))\n\n\n\n# save a png\n\n\npng\n(\n\"iris\"\n)",
            "title": "Home"
        },
        {
            "location": "/#intro-to-plots-in-julia",
            "text": "Author: Thomas Breloff (@tbreloff)  Data visualization has a complicated history, with plotting software making trade-offs between features vs simplicity, speed vs beauty, and static vs dynamic.  Some make a visualization and never change it, others must make updates in real-time.  Plots is a visualization interface and toolset.  It sits above other visualization \"backends\", connecting commands with implementation.  If one backend does not support your desired features, or make the right trade-offs, just switch to another backend with one command.  No need to change your code.  No need to learn something new.  Plots might be the last plotting package you ever learn.  My goals with the package are:   Powerful .  Do more with less.  Complex visualizations become easy.  Intuitive .  Start generating plots without reading volumes of documentation.  Commands should \"just work\".  Concise .  Less code means fewer mistakes and more efficient development/analysis.  Flexible .  Produce your favorite plots from your favorite package, but quicker and simpler.  Consistent .  Don't commit to one graphics package.  Use the same code and access the strengths of all  backends .  Lightweight .  Very few dependencies, since backends are loaded and initialized dynamically.  Smart .  It's not quite AGI, but Plots should figure out what you  want  it to do... not just what you  tell  it.   Use the  preprocessing pipeline  in Plots to fully describe your visualization before it calls the backend code.  This maintains modularity and allows for efficient separation of front end code, algorithms, and backend graphics.  Tap into the extensive visualization functionality enabled by the  Plots ecosystem , and easily build your own complex graphics components with  recipes .  Please add wishlist items, bugs, or any other comments/questions to the  issues list , and  join the conversation on gitter .",
            "title": "Intro to Plots in Julia"
        },
        {
            "location": "/#simple-is-beautiful",
            "text": "Lorenz Attractor  # initialize the attractor  n   =   1500  dt   =   0.02  \u03c3 ,   \u03c1 ,   \u03b2   =   10. ,   28. ,   8 / 3  x ,   y ,   z   =   1. ,   1. ,   1.  # initialize a 3D plot with 1 empty series  plt   =   path3d ( 1 ,   xlim = ( - 25 , 25 ),   ylim = ( - 25 , 25 ),   zlim = ( 0 , 50 ), \n                 xlab   =   \"x\" ,   ylab   =   \"y\" ,   zlab   =   \"z\" , \n                 title   =   \"Lorenz Attractor\" ,   marker   =   1 )  # build an animated gif, saving every 10th frame  @gif   for   i = 1 : n \n     dx   =   \u03c3 * ( y   -   x )       ;   x   +=   dt   *   dx \n     dy   =   x * ( \u03c1   -   z )   -   y   ;   y   +=   dt   *   dy \n     dz   =   x * y   -   \u03b2 * z       ;   z   +=   dt   *   dz \n     push! ( plt ,   x ,   y ,   z )  end   every   10    Make some waves  using   Plots  pyplot ( leg = false ,   ticks = nothing )  x   =   y   =   linspace ( - 5 ,   5 ,   40 )  zs   =   zeros ( 0 , 40 )  @gif   for   i   in   linspace ( 0 ,   2 \u03c0 ,   100 ) \n     f ( x , y )   =   sin ( x   +   10 sin ( i ))   +   cos ( y ) \n\n     # create a plot with 3 subplots and a custom layout \n     l   =   @layout   [ a { 0.7 w }   b ;   c { 0.2 h }] \n     p   =   plot ( x ,   y ,   f ,   st   =   [ : surface ,   : contourf ],   layout = l ) \n\n     # add a tracking line \n     fixed_x   =   zeros ( 40 ) \n     z   =   map ( f , fixed_x , y ) \n     plot! ( p [ 1 ],   fixed_x ,   y ,   z ,   line   =   ( : black ,   5 ,   0.2 )) \n     vline! ( p [ 2 ],   [ 0 ],   line   =   ( : black ,   5 )) \n\n     # add to and show the tracked values over time \n     zs   =   vcat ( zs ,   z ' ) \n     plot! ( p [ 3 ],   zs ,   alpha   =   0.2 ,   palette   =   cgrad ( : blues ) . colors )  end    Iris Dataset  # load a dataset  using   RDatasets  iris   =   dataset ( \"datasets\" ,   \"iris\" );  # load the StatPlots recipes (for DataFrames) available via:  # Pkg.add(\"StatPlots\")  using   StatPlots  # Scatter plot with some custom settings  scatter ( iris ,   : SepalLength ,   : SepalWidth ,   group =: Species , \n         title   =   \"My awesome plot\" , \n         xlabel   =   \"Length\" ,   ylabel   =   \"Width\" , \n         m = ( 0.5 ,   [ : cross   : hex   : star7 ],   12 ), \n         bg = RGB ( . 2 , . 2 , . 2 ))  # save a png  png ( \"iris\" )",
            "title": "Simple is Beautiful"
        },
        {
            "location": "/install/",
            "text": "Install\n\n\nFirst, add the package\n\n\nPkg\n.\nadd\n(\n\"Plots\"\n)\n\n\n\n# if you want the latest features:\n\n\nPkg\n.\ncheckout\n(\n\"Plots\"\n)\n\n\n\n# or for the bleeding edge:\n\n\nPkg\n.\ncheckout\n(\n\"Plots\"\n,\n \n\"dev\"\n)\n\n\n\n\n\n\nthen get any plotting packages you need (obviously, you should get at least one \nbackend\n).\n\n\nPkg\n.\nadd\n(\n\"PyPlot\"\n)\n\n\nPkg\n.\nadd\n(\n\"GR\"\n)\n\n\nPkg\n.\nadd\n(\n\"UnicodePlots\"\n)\n\n\nPkg\n.\nadd\n(\n\"PlotlyJS\"\n)\n\n\n\n\n\n\nFinally, you may wish to add some extensions from the \nPlots ecosystem\n:\n\n\nPkg\n.\nadd\n(\n\"StatPlots\"\n)\n\n\nPkg\n.\nadd\n(\n\"PlotRecipes\"\n)\n\n\n\n\n\n\n\n\nInitialize\n\n\nusing\n \nPlots\n \n# or StatPlots, or PlotRecipes\n\n\n\n\n\n\nChoose a backend\n, and optionally override default settings at the same time:\n\n\npyplot\n(\nsize\n \n=\n \n(\n300\n,\n300\n),\n \nlegend\n \n=\n \nfalse\n)\n\n\n\n\n\n\n\nTip: Backend methods are lowercase, and match the corresponding backend package name.\n\n\n\n\n\nTip: The underlying plotting backends are not imported and initialized immediately, thus they are\nloaded on demand to reduce dependencies.\n\n\n\n\n\nTip: Plots will pick a default backend for you automatically based on what backends are installed.  You can\noverride this choice by setting an environment variable in your ~/.juliarc.jl file: ENV[\"PLOTS_DEFAULT_BACKEND\"] = \"PlotlyJS\"\n\n\n\n\n\nTip: You can override standard default values in your ~/.juliarc.jl file: PLOTS_DEFAULTS = Dict(:markersize => 10, :legend => false)",
            "title": "Installation"
        },
        {
            "location": "/install/#install",
            "text": "First, add the package  Pkg . add ( \"Plots\" )  # if you want the latest features:  Pkg . checkout ( \"Plots\" )  # or for the bleeding edge:  Pkg . checkout ( \"Plots\" ,   \"dev\" )   then get any plotting packages you need (obviously, you should get at least one  backend ).  Pkg . add ( \"PyPlot\" )  Pkg . add ( \"GR\" )  Pkg . add ( \"UnicodePlots\" )  Pkg . add ( \"PlotlyJS\" )   Finally, you may wish to add some extensions from the  Plots ecosystem :  Pkg . add ( \"StatPlots\" )  Pkg . add ( \"PlotRecipes\" )",
            "title": "Install"
        },
        {
            "location": "/install/#initialize",
            "text": "using   Plots   # or StatPlots, or PlotRecipes   Choose a backend , and optionally override default settings at the same time:  pyplot ( size   =   ( 300 , 300 ),   legend   =   false )   \nTip: Backend methods are lowercase, and match the corresponding backend package name.  \nTip: The underlying plotting backends are not imported and initialized immediately, thus they are\nloaded on demand to reduce dependencies.  \nTip: Plots will pick a default backend for you automatically based on what backends are installed.  You can\noverride this choice by setting an environment variable in your ~/.juliarc.jl file: ENV[\"PLOTS_DEFAULT_BACKEND\"] = \"PlotlyJS\"  \nTip: You can override standard default values in your ~/.juliarc.jl file: PLOTS_DEFAULTS = Dict(:markersize => 10, :legend => false)",
            "title": "Initialize"
        },
        {
            "location": "/basics/",
            "text": "Basic Concepts\n\n\nUse \nplot\n to create a new plot object, and \nplot!\n to add to an existing one:\n\n\nplot\n(\nargs\n...\n;\n \nkw\n...\n)\n                  \n# creates a new Plot, and set it to be the `current`\n\n\nplot!\n(\nargs\n...\n;\n \nkw\n...\n)\n                 \n# modifies Plot `current()`\n\n\nplot!\n(\nplt\n,\n \nargs\n...\n;\n \nkw\n...\n)\n            \n# modifies Plot `plt`\n\n\n\n\n\n\nThe graphic is not shown implicitly, only when \"displayed\".  This will happen automatically when returned to a REPL prompt or to an IJulia cell.  There are \nmany other options\n as well.\n\n\nInput arguments can take \nmany forms\n.  Some valid examples:\n\n\nplot\n()\n                                    \n# empty Plot object\n\n\nplot\n(\n4\n)\n                                   \n# initialize with 4 empty series\n\n\nplot\n(\nrand\n(\n10\n))\n                            \n# 1 series... x = 1:10\n\n\nplot\n(\nrand\n(\n10\n,\n5\n))\n                          \n# 5 series... x = 1:10\n\n\nplot\n(\nrand\n(\n10\n),\n \nrand\n(\n10\n))\n                  \n# 1 series\n\n\nplot\n(\nrand\n(\n10\n,\n5\n),\n \nrand\n(\n10\n))\n                \n# 5 series... y is the same for all\n\n\nplot\n(\nsin\n,\n \nrand\n(\n10\n))\n                       \n# y = sin(x)\n\n\nplot\n(\nrand\n(\n10\n),\n \nsin\n)\n                       \n# same... y = sin(x)\n\n\nplot\n([\nsin\n,\ncos\n],\n \n0\n:\n0.1\n:\n\u03c0\n)\n                  \n# 2 series, sin(x) and cos(x)\n\n\nplot\n([\nsin\n,\ncos\n],\n \n0\n,\n \n\u03c0\n)\n                     \n# sin and cos on the range [0, \u03c0]\n\n\nplot\n(\n1\n:\n10\n,\n \nAny\n[\nrand\n(\n10\n),\n \nsin\n])\n            \n# 2 series: rand(10) and map(sin,x)\n\n\nplot\n(\ndataset\n(\n\"Ecdat\"\n,\n \n\"Airline\"\n),\n \n:\nCost\n)\n  \n# the :Cost column from a DataFrame... must import StatPlots\n\n\n\n\n\n\nKeyword arguments\n allow for customization of the plot, subplots, axes, and series.  They follow consistent rules as much as possible, and you'll avoid common pitfalls if you read this section carefully:\n\n\n\n\nMany arguments have aliases which are \nreplaced during preprocessing\n.  \nc\n is the same as \ncolor\n, \nm\n is the same as \nmarker\n, etc.  You can choose a verbosity that you are comfortable with.\n\n\nThere are some \nspecial arguments\n which magically set many related things at once.\n\n\nIf the argument is a \"matrix-type\", then \neach column will map to a series\n, cycling through columns if there are fewer columns than series.  In this sense, a vector is treated just like an \"nx1 matrix\".\n\n\nMany arguments accept many different types... for example the color (also markercolor, fillcolor, etc) argument will accept strings or symbols with a color name, or any Colors.Colorant, or a ColorScheme, or a symbol representing a ColorGradient, or an AbstractVector of colors/symbols/etc...\n\n\n\n\n\n\nUseful Tips\n\n\n\nTip: A common error is to pass a Vector when you intend for each item to apply to only one series.  Instead of an n-length Vector, pass a 1xn Matrix.\n\n\n\n\n\n  \nTip: You can update certain plot settings after plot creation:\n\n  \n\n    plot!(title = \"New Title\", xlabel = \"New xlabel\", ylabel = \"New ylabel\")\n    plot!(xlims = (0, 5.5), ylims = (-2.2, 6), xticks = 0:0.5:10, yticks = [0,1,5,10])\n\n    # or using magic:\n    plot!(xaxis = (\"mylabel\", :log10, :flip))\n    xaxis!(\"mylabel\", :log10, :flip)\n  \n\n\n\n\n\n\nTip: With \nsupported backends\n, you can pass a Plots.Shape object for the marker/markershape arguments.  Shape takes a vector of 2-tuples in the constructor, defining the points of the polygon's shape in a unit-scaled coordinate space.  To make a square, for example, you could do: Shape([(1,1),(1,-1),(-1,-1),(-1,1)])\n\n\n\n\n\nTip: You can see the default value for a given argument with default(arg::Symbol), and set the default value with default(arg::Symbol, value) or default(; kw...).  For example set the\ndefault window size and whether we should show a legend with default(size=(600,400), leg=false).\n\n\n\n\n\nTip: Call `gui()` to display the plot in a window.  Interactivity depends on backend.  Plotting at the REPL (without semicolon) implicitly calls `gui()`.\n\n\n\n\n\nTip: See the \nexamples\n for plotting ideas and features.",
            "title": "Basics"
        },
        {
            "location": "/basics/#basic-concepts",
            "text": "Use  plot  to create a new plot object, and  plot!  to add to an existing one:  plot ( args ... ;   kw ... )                    # creates a new Plot, and set it to be the `current`  plot! ( args ... ;   kw ... )                   # modifies Plot `current()`  plot! ( plt ,   args ... ;   kw ... )              # modifies Plot `plt`   The graphic is not shown implicitly, only when \"displayed\".  This will happen automatically when returned to a REPL prompt or to an IJulia cell.  There are  many other options  as well.  Input arguments can take  many forms .  Some valid examples:  plot ()                                      # empty Plot object  plot ( 4 )                                     # initialize with 4 empty series  plot ( rand ( 10 ))                              # 1 series... x = 1:10  plot ( rand ( 10 , 5 ))                            # 5 series... x = 1:10  plot ( rand ( 10 ),   rand ( 10 ))                    # 1 series  plot ( rand ( 10 , 5 ),   rand ( 10 ))                  # 5 series... y is the same for all  plot ( sin ,   rand ( 10 ))                         # y = sin(x)  plot ( rand ( 10 ),   sin )                         # same... y = sin(x)  plot ([ sin , cos ],   0 : 0.1 : \u03c0 )                    # 2 series, sin(x) and cos(x)  plot ([ sin , cos ],   0 ,   \u03c0 )                       # sin and cos on the range [0, \u03c0]  plot ( 1 : 10 ,   Any [ rand ( 10 ),   sin ])              # 2 series: rand(10) and map(sin,x)  plot ( dataset ( \"Ecdat\" ,   \"Airline\" ),   : Cost )    # the :Cost column from a DataFrame... must import StatPlots   Keyword arguments  allow for customization of the plot, subplots, axes, and series.  They follow consistent rules as much as possible, and you'll avoid common pitfalls if you read this section carefully:   Many arguments have aliases which are  replaced during preprocessing .   c  is the same as  color ,  m  is the same as  marker , etc.  You can choose a verbosity that you are comfortable with.  There are some  special arguments  which magically set many related things at once.  If the argument is a \"matrix-type\", then  each column will map to a series , cycling through columns if there are fewer columns than series.  In this sense, a vector is treated just like an \"nx1 matrix\".  Many arguments accept many different types... for example the color (also markercolor, fillcolor, etc) argument will accept strings or symbols with a color name, or any Colors.Colorant, or a ColorScheme, or a symbol representing a ColorGradient, or an AbstractVector of colors/symbols/etc...",
            "title": "Basic Concepts"
        },
        {
            "location": "/basics/#useful-tips",
            "text": "Tip: A common error is to pass a Vector when you intend for each item to apply to only one series.  Instead of an n-length Vector, pass a 1xn Matrix.  \n   Tip: You can update certain plot settings after plot creation: \n   \n    plot!(title = \"New Title\", xlabel = \"New xlabel\", ylabel = \"New ylabel\")\n    plot!(xlims = (0, 5.5), ylims = (-2.2, 6), xticks = 0:0.5:10, yticks = [0,1,5,10])\n\n    # or using magic:\n    plot!(xaxis = (\"mylabel\", :log10, :flip))\n    xaxis!(\"mylabel\", :log10, :flip)\n     \nTip: With  supported backends , you can pass a Plots.Shape object for the marker/markershape arguments.  Shape takes a vector of 2-tuples in the constructor, defining the points of the polygon's shape in a unit-scaled coordinate space.  To make a square, for example, you could do: Shape([(1,1),(1,-1),(-1,-1),(-1,1)])  \nTip: You can see the default value for a given argument with default(arg::Symbol), and set the default value with default(arg::Symbol, value) or default(; kw...).  For example set the\ndefault window size and whether we should show a legend with default(size=(600,400), leg=false).  \nTip: Call `gui()` to display the plot in a window.  Interactivity depends on backend.  Plotting at the REPL (without semicolon) implicitly calls `gui()`.  \nTip: See the  examples  for plotting ideas and features.",
            "title": "Useful Tips"
        },
        {
            "location": "/input_data/",
            "text": "Input Data\n\n\nPart of the power of Plots lies is in the many combinations of allowed input data.\nYou shouldn't spend your time transforming and massaging your data into a specific format.\nLet Plots do that for you.\n\n\nThere are a few rules to remember, and you'll be a power user in no time.\n\n\nInputs are arguments, not keywords\n\n\nWhile \nplot(x = 1:10, y = rand(10))\n will work as expected, it is not the preferred method.  In fact,\nthis method will simply call \nplot(1:10, rand(10))\n.  Instead,\nuse \nplot(rand(10))\n.  In this case, a single input will be mapped to the \n:y\n keyword, and a missing\nvalue for \n:x\n will impute a unit range \n1:10\n.\n\n\nThe reason lies in the flexibility of Julia's multiple dispatch, where every combination of input types\ncan have unique behavior, when desired.\n\n\nColumns are series\n\n\nIn most cases, passing a (\nn\n \u00d7 \nm\n) matrix of values (numbers, etc) will create \nm\n series, each with \nn\n data points.  This follows a consistent rule\u2026 vectors apply to a series, matrices apply to many series.  This rule carries into keyword arguments.  \nscatter(rand(10,4), markershape = [:circle, :rect])\n will create 4 series, each assigned the markershape vector [:circle,:rect].  However, \nscatter(rand(10,4), markershape = [:circle :rect])\n will create 4 series, with series 1 and 3 having markers shaped as \n:circle\n and series 2 and 4 having markers shaped as \n:rect\n (i.e. as squares).  The difference is that in the first example, it is a length-2 column vector, and in the second example it is a (1 \u00d7 2) row vector (a Matrix).\n\n\nThe flexibility and power of this can be illustrated by the following piece of code:\n\n\nusing\n \nPlots\n;\n \ngr\n()\n\n\n\n# 10 data points in 4 series\n\n\nxs\n \n=\n \n0\n \n:\n \n2\n\u03c0\n/\n10\n \n:\n \n2\n\u03c0\n\n\ndata\n \n=\n \n[\nsin\n.\n(\nxs\n)\n \ncos\n.\n(\nxs\n)\n \n2\nsin\n.\n(\nxs\n)\n \n2\ncos\n.\n(\nxs\n)]\n\n\n\n# We put labels in a row vector: applies to each series\n\n\nlabels\n \n=\n \n[\n\"Apples\"\n \n\"Oranges\"\n \n\"Hats\"\n \n\"Shoes\"\n]\n\n\n\n# Marker shapes in a column vector: applies to data points\n\n\nmarkershapes\n \n=\n \n[\n:\ncircle\n,\n \n:\nstar5\n]\n\n\n\n# Marker colors in a matrix: applies to series and data points\n\n\nmarkercolors\n \n=\n \n[\n:\ngreen\n \n:\norange\n \n:\nblack\n \n:\npurple\n\n                \n:\nred\n   \n:\nyellow\n \n:\nbrown\n \n:\nwhite\n]\n\n\n\nplot\n(\nxs\n,\n \ndata\n,\n \nlabel\n \n=\n \nlabels\n,\n \nshape\n \n=\n \nmarkershapes\n,\n \ncolor\n \n=\n \nmarkercolors\n,\n\n     \nmarkersize\n \n=\n \n10\n)\n\n\n\n\n\n\nThis example plots the four series with different labels, marker shapes, and marker colors by combining row and column vectors to decorate the data.  The result is:\n\n\n\nUnconnected Data within same groups\n\n\nAs shown in the examples, you can plot a single polygon by using a single call to \nplot\n usingi the \n:path\n line type. You can use several calls to \nplot\n to draw several polygons\n\n\nNow, let's say you're plotting \nn\n polygons grouped into \ng\n groups, with \nn\n < \ng\n. While you can use \nplot\n to draw separate polygons with each call, you cannot group two separate plots back into a single group. You'll end up with \nn\n groups in the legend, rather than \ng\n groups.\n\n\nTo adress this, you can use \nNaN\n as a path separator. A call to \nplot\n would then draw one path with disjoints The following code draws \nn=4\n rectangles in \ng=2\n groups.\n\n\nusing\n \nPlots\n;\n \nplotly\n()\n\n\n\nfunction\n \nrectangle_from_coords\n(\nxb\n,\nyb\n,\nxt\n,\nyt\n)\n\n    \n[\n\n        \nxb\n \nyb\n\n        \nxt\n \nyb\n\n        \nxt\n \nyt\n\n        \nxb\n \nyt\n\n        \nxb\n \nyb\n\n        \nNaN\n \nNaN\n\n    \n]\n\n\nend\n\n\n\nsome_rects\n=\n[\n\n    \nrectangle_from_coords\n(\n1\n \n,\n1\n \n,\n5\n \n,\n5\n \n)\n\n    \nrectangle_from_coords\n(\n10\n,\n10\n,\n15\n,\n15\n)\n\n    \n]\n\n\nother_rects\n=\n[\n\n    \nrectangle_from_coords\n(\n1\n \n,\n10\n,\n5\n \n,\n15\n)\n\n    \nrectangle_from_coords\n(\n10\n,\n1\n \n,\n15\n,\n5\n \n)\n\n    \n]\n\n\n\nplot\n(\nsome_rects\n[\n:\n,\n1\n],\n \nsome_rects\n[\n:\n,\n2\n],\nlabel\n=\n\"some group\"\n)\n\n\nplot!\n(\nother_rects\n[\n:\n,\n1\n],\n \nother_rects\n[\n:\n,\n2\n],\nlabel\n=\n\"other group\"\n)\n\n\n\n\n\n\nThis examples produces the following:\n\n\n\nDataFrames support\n\n\nUsing the \nStatPlots\n extension package, you can pass a \nDataFrame\n as the first argument (similar to Gadfly or R's ggplot2).  For data fields or certain attributes (such as \ngroup\n) a symbol will be replaced with the corresponding column(s) of the \nDataFrame\n.  Additionally, the column name might be used as the   An example:\n\n\nusing\n \nStatPlots\n,\n \nRDatasets\n\n\niris\n \n=\n \ndataset\n(\n\"datasets\"\n,\n \n\"iris\"\n)\n\n\nscatter\n(\niris\n,\n \n:\nSepalLength\n,\n \n:\nSepalWidth\n,\n \ngroup\n=:\nSpecies\n,\n\n        \nm\n=\n(\n0.5\n,\n \n[\n:+\n \n:\nh\n \n:\nstar7\n],\n \n12\n),\n \nbg\n=\nRGB\n(\n.\n2\n,\n.\n2\n,\n.\n2\n))\n\n\n\n\n\n\n\n\nFunctions\n\n\nFunctions can typically be used in place of input data, and they will be mapped as needed. 2D and 3D parametric plots can also be created, and ranges can be given as vectors or min/max.  For example, here are alternative methods to create the same plot:\n\n\nusing\n \nPlots\n\n\ntmin\n \n=\n \n0\n\n\ntmax\n \n=\n \n4\n\u03c0\n\n\ntvec\n \n=\n \nlinspace\n(\ntmin\n,\n \ntmax\n,\n \n100\n)\n\n\n\nplot\n(\nsin\n(\ntvec\n),\n \ncos\n(\ntvec\n))\n\n\nplot\n(\nsin\n,\n \ncos\n,\n \ntvec\n)\n\n\nplot\n(\nsin\n,\n \ncos\n,\n \ntmin\n,\n \ntmax\n)\n\n\n\n\n\n\nVectors of functions are allowed as well (one series per function).\n\n\nImages\n\n\nImages can be directly added to plots by using the \nImages.jl\n library. For example, one can import a raster image and plot it with Plots via the commands:\n\n\nusing\n \nPlots\n,\nImages\n\n\nimg\n \n=\n \nload\n(\n\"image.png\"\n)\n\n\nplot\n(\nimg\n)\n\n\n\n\n\n\nPDF graphics can also be added to Plots.jl plots using \nload(\"image.pdf\")\n. Note that Images.jl requires that the PDF color scheme is RGB.\n\n\nShapes\n\n\nCheck out \nthis tutorial\n to save Gotham:",
            "title": "Input Data"
        },
        {
            "location": "/input_data/#input-data",
            "text": "Part of the power of Plots lies is in the many combinations of allowed input data.\nYou shouldn't spend your time transforming and massaging your data into a specific format.\nLet Plots do that for you.  There are a few rules to remember, and you'll be a power user in no time.",
            "title": "Input Data"
        },
        {
            "location": "/input_data/#inputs-are-arguments-not-keywords",
            "text": "While  plot(x = 1:10, y = rand(10))  will work as expected, it is not the preferred method.  In fact,\nthis method will simply call  plot(1:10, rand(10)) .  Instead,\nuse  plot(rand(10)) .  In this case, a single input will be mapped to the  :y  keyword, and a missing\nvalue for  :x  will impute a unit range  1:10 .  The reason lies in the flexibility of Julia's multiple dispatch, where every combination of input types\ncan have unique behavior, when desired.",
            "title": "Inputs are arguments, not keywords"
        },
        {
            "location": "/input_data/#columns-are-series",
            "text": "In most cases, passing a ( n  \u00d7  m ) matrix of values (numbers, etc) will create  m  series, each with  n  data points.  This follows a consistent rule\u2026 vectors apply to a series, matrices apply to many series.  This rule carries into keyword arguments.   scatter(rand(10,4), markershape = [:circle, :rect])  will create 4 series, each assigned the markershape vector [:circle,:rect].  However,  scatter(rand(10,4), markershape = [:circle :rect])  will create 4 series, with series 1 and 3 having markers shaped as  :circle  and series 2 and 4 having markers shaped as  :rect  (i.e. as squares).  The difference is that in the first example, it is a length-2 column vector, and in the second example it is a (1 \u00d7 2) row vector (a Matrix).  The flexibility and power of this can be illustrated by the following piece of code:  using   Plots ;   gr ()  # 10 data points in 4 series  xs   =   0   :   2 \u03c0 / 10   :   2 \u03c0  data   =   [ sin . ( xs )   cos . ( xs )   2 sin . ( xs )   2 cos . ( xs )]  # We put labels in a row vector: applies to each series  labels   =   [ \"Apples\"   \"Oranges\"   \"Hats\"   \"Shoes\" ]  # Marker shapes in a column vector: applies to data points  markershapes   =   [ : circle ,   : star5 ]  # Marker colors in a matrix: applies to series and data points  markercolors   =   [ : green   : orange   : black   : purple \n                 : red     : yellow   : brown   : white ]  plot ( xs ,   data ,   label   =   labels ,   shape   =   markershapes ,   color   =   markercolors , \n      markersize   =   10 )   This example plots the four series with different labels, marker shapes, and marker colors by combining row and column vectors to decorate the data.  The result is:",
            "title": "Columns are series"
        },
        {
            "location": "/input_data/#unconnected-data-within-same-groups",
            "text": "As shown in the examples, you can plot a single polygon by using a single call to  plot  usingi the  :path  line type. You can use several calls to  plot  to draw several polygons  Now, let's say you're plotting  n  polygons grouped into  g  groups, with  n  <  g . While you can use  plot  to draw separate polygons with each call, you cannot group two separate plots back into a single group. You'll end up with  n  groups in the legend, rather than  g  groups.  To adress this, you can use  NaN  as a path separator. A call to  plot  would then draw one path with disjoints The following code draws  n=4  rectangles in  g=2  groups.  using   Plots ;   plotly ()  function   rectangle_from_coords ( xb , yb , xt , yt ) \n     [ \n         xb   yb \n         xt   yb \n         xt   yt \n         xb   yt \n         xb   yb \n         NaN   NaN \n     ]  end  some_rects = [ \n     rectangle_from_coords ( 1   , 1   , 5   , 5   ) \n     rectangle_from_coords ( 10 , 10 , 15 , 15 ) \n     ]  other_rects = [ \n     rectangle_from_coords ( 1   , 10 , 5   , 15 ) \n     rectangle_from_coords ( 10 , 1   , 15 , 5   ) \n     ]  plot ( some_rects [ : , 1 ],   some_rects [ : , 2 ], label = \"some group\" )  plot! ( other_rects [ : , 1 ],   other_rects [ : , 2 ], label = \"other group\" )   This examples produces the following:",
            "title": "Unconnected Data within same groups"
        },
        {
            "location": "/input_data/#dataframes-support",
            "text": "Using the  StatPlots  extension package, you can pass a  DataFrame  as the first argument (similar to Gadfly or R's ggplot2).  For data fields or certain attributes (such as  group ) a symbol will be replaced with the corresponding column(s) of the  DataFrame .  Additionally, the column name might be used as the   An example:  using   StatPlots ,   RDatasets  iris   =   dataset ( \"datasets\" ,   \"iris\" )  scatter ( iris ,   : SepalLength ,   : SepalWidth ,   group =: Species , \n         m = ( 0.5 ,   [ :+   : h   : star7 ],   12 ),   bg = RGB ( . 2 , . 2 , . 2 ))",
            "title": "DataFrames support"
        },
        {
            "location": "/input_data/#functions",
            "text": "Functions can typically be used in place of input data, and they will be mapped as needed. 2D and 3D parametric plots can also be created, and ranges can be given as vectors or min/max.  For example, here are alternative methods to create the same plot:  using   Plots  tmin   =   0  tmax   =   4 \u03c0  tvec   =   linspace ( tmin ,   tmax ,   100 )  plot ( sin ( tvec ),   cos ( tvec ))  plot ( sin ,   cos ,   tvec )  plot ( sin ,   cos ,   tmin ,   tmax )   Vectors of functions are allowed as well (one series per function).",
            "title": "Functions"
        },
        {
            "location": "/input_data/#images",
            "text": "Images can be directly added to plots by using the  Images.jl  library. For example, one can import a raster image and plot it with Plots via the commands:  using   Plots , Images  img   =   load ( \"image.png\" )  plot ( img )   PDF graphics can also be added to Plots.jl plots using  load(\"image.pdf\") . Note that Images.jl requires that the PDF color scheme is RGB.",
            "title": "Images"
        },
        {
            "location": "/input_data/#shapes",
            "text": "Check out  this tutorial  to save Gotham:",
            "title": "Shapes"
        },
        {
            "location": "/attributes/",
            "text": "<!--\nfunction autoResize(id){\n    var newheight;\n    var newwidth;\n\n    if(document.getElementById){\n        newheight = document.getElementById(id).contentWindow.document .body.scrollHeight;\n        newwidth = document.getElementById(id).contentWindow.document .body.scrollWidth;\n    }\n\n    document.getElementById(id).height = (newheight) + \"px\";\n    document.getElementById(id).width = (newwidth) + \"px\";\n}\n//-->\n\n\n\n\n\n\nAttributes\n\n\nIn Plots, input data is passed positionally (for example, the \ny\n in \nplot(y)\n), and attributes are passed as keywords (for example, \nplot(y, color = :blue)\n).\n\n\nTip: Most of the information on this page is available from your Julia session with the function \nplotattr\n, e.g. \nplotattr(:Series)\n to print a list of all series attributes, or \nplotattr(\"ms\")\n to print the aliases and descriptions of \nmarkersize\n.\n\n\n\n\n\nAliases\n\n\nKeywords can take a range of values through the \nalias mechanic\n.  For example, \nplot(y, color = :blue)\n is really interpreted as \nplot(y, seriescolor = :blue)\n.  Each attribute has a number of aliases (see the charts below), which are available to avoid the pain of constantly looking up plotting API documentation because you forgot the argument name.  \nc\n, \ncolor\n, and \nseriescolor\n all mean the same thing, and in fact those are eventually converted into the more precise attributes \nlinecolor\n, \nmarkercolor\n, \nmarkerstrokecolor\n, and \nfillcolor\n (which you can then override if desired).\n\n\n\nTip: Use aliases for one-off analysis and visualization, but use the true keyword name for long-lived library code to avoid confusion.\n\n\n\n\n\nTip: As of this writing, aliases do not work inside recipes!!\n\n\n\n\n\n\nMagic Arguments\n\n\nSome arguments encompass smart shorthands for setting many related arguments at the same time.  Plots uses type checking and multiple dispatch to smartly \"figure out\" which values apply to which argument.  Pass in a tuple of values.  Single values will be first wrapped in a tuple before processing.\n\n\naxis (and xaxis/yaxis/zaxis)\n\n\nPassing a tuple of settings to the \nxaxis\n argument will allow the quick definition\nof \nxlabel\n, \nxlim\n, \nxticks\n, \nxscale\n, \nxflip\n, and \nxtickfont\n.  The following are equivalent:\n\n\nplot\n(\ny\n,\n \nxaxis\n \n=\n \n(\n\"my label\"\n,\n \n(\n0\n,\n10\n),\n \n0\n:\n0.5\n:\n10\n,\n \n:\nlog\n,\n \n:\nflip\n,\n \nfont\n(\n20\n,\n \n\"Courier\"\n)))\n\n\n\nplot\n(\ny\n,\n \nxlabel\n \n=\n \n\"my label\"\n,\n\n        \nxlims\n \n=\n \n(\n0\n,\n10\n),\n\n        \nxticks\n \n=\n \n0\n:\n0.5\n:\n10\n,\n\n        \nxscale\n \n=\n \n:\nlog\n,\n\n        \nxflip\n \n=\n \ntrue\n,\n\n        \nxtickfont\n \n=\n \nfont\n(\n20\n,\n \n\"Courier\"\n))\n\n\n\n\n\n\nNote that \nyaxis\n and \nzaxis\n work similarly, and \naxis\n will apply to all.\n\n\nline\n\n\nSet attributes corresponding to a series line.  Aliases: \nl\n.  The following are equivalent:\n\n\nplot\n(\ny\n,\n \nline\n \n=\n \n(\n:\nsteppre\n,\n \n:\ndot\n,\n \n:\narrow\n,\n \n0.5\n,\n \n4\n,\n \n:\nred\n))\n\n\n\nplot\n(\ny\n,\n \nseriestype\n \n=\n \n:\nsteppre\n,\n\n        \nlinestyle\n \n=\n \n:\ndot\n,\n\n        \narrow\n \n=\n \n:\narrow\n,\n\n        \nlinealpha\n \n=\n \n0.5\n,\n\n        \nlinewidth\n \n=\n \n4\n,\n\n        \nlinecolor\n \n=\n \n:\nred\n)\n\n\n\n\n\n\nfill\n\n\nSet attributes corresponding to a series fill area.  Aliases: \nf\n, \narea\n.  The following are equivalent:\n\n\nplot\n(\ny\n,\n \nfill\n \n=\n \n(\n0\n,\n \n0.5\n,\n \n:\nred\n))\n\n\n\nplot\n(\ny\n,\n \nfillrange\n \n=\n \n0\n,\n\n        \nfillalpha\n \n=\n \n0.5\n,\n\n        \nfillcolor\n \n=\n \n:\nred\n)\n\n\n\n\n\n\nmarker\n\n\nSet attributes corresponding to a series marker.  Aliases: \nm\n, \nmark\n.  The following are equivalent:\n\n\nscatter\n(\ny\n,\n \nmarker\n \n=\n \n(\n:\nhexagon\n,\n \n20\n,\n \n0.6\n,\n \n:\ngreen\n,\n \nstroke\n(\n3\n,\n \n0.2\n,\n \n:\nblack\n,\n \n:\ndot\n)))\n\n\n\nscatter\n(\ny\n,\n \nmarkershape\n \n=\n \n:\nhexagon\n,\n\n           \nmarkersize\n \n=\n \n20\n,\n\n           \nmarkeralpha\n \n=\n \n0.6\n,\n\n           \nmarkercolor\n \n=\n \n:\ngreen\n,\n\n           \nmarkerstrokewidth\n \n=\n \n3\n,\n\n           \nmarkerstrokealpha\n \n=\n \n0.2\n,\n\n           \nmarkerstrokecolor\n \n=\n \n:\nblack\n,\n\n           \nmarkerstrokestyle\n \n=\n \n:\ndot\n)\n\n\n\n\n\n\n\n\nSeries\n\n\nThese attributes apply to individual series (lines, scatters, heatmaps, etc)\n\n\nYou need a Frames Capable browser to view this content.\n\n\n\n\n\nPlot\n\n\nThese attributes apply to the full Plot.  (A Plot contains a tree-like layout of Subplots)\n\n\nYou need a Frames Capable browser to view this content.\n\n\n\n\n\nSubplot\n\n\nThese attributes apply to settings for individual Subplots.\n\n\nYou need a Frames Capable browser to view this content.\n\n\n\n\n\nAxis\n\n\nThese attributes apply to an individual Axis in a Subplot (for example the \nsubplot[:xaxis]\n)\n\n\nYou need a Frames Capable browser to view this content.",
            "title": "Attributes"
        },
        {
            "location": "/attributes/#attributes",
            "text": "In Plots, input data is passed positionally (for example, the  y  in  plot(y) ), and attributes are passed as keywords (for example,  plot(y, color = :blue) ). \nTip: Most of the information on this page is available from your Julia session with the function  plotattr , e.g.  plotattr(:Series)  to print a list of all series attributes, or  plotattr(\"ms\")  to print the aliases and descriptions of  markersize .",
            "title": "Attributes"
        },
        {
            "location": "/attributes/#aliases",
            "text": "Keywords can take a range of values through the  alias mechanic .  For example,  plot(y, color = :blue)  is really interpreted as  plot(y, seriescolor = :blue) .  Each attribute has a number of aliases (see the charts below), which are available to avoid the pain of constantly looking up plotting API documentation because you forgot the argument name.   c ,  color , and  seriescolor  all mean the same thing, and in fact those are eventually converted into the more precise attributes  linecolor ,  markercolor ,  markerstrokecolor , and  fillcolor  (which you can then override if desired).  \nTip: Use aliases for one-off analysis and visualization, but use the true keyword name for long-lived library code to avoid confusion.  \nTip: As of this writing, aliases do not work inside recipes!!",
            "title": "Aliases"
        },
        {
            "location": "/attributes/#magic-arguments",
            "text": "Some arguments encompass smart shorthands for setting many related arguments at the same time.  Plots uses type checking and multiple dispatch to smartly \"figure out\" which values apply to which argument.  Pass in a tuple of values.  Single values will be first wrapped in a tuple before processing.",
            "title": "Magic Arguments"
        },
        {
            "location": "/attributes/#axis-and-xaxisyaxiszaxis",
            "text": "Passing a tuple of settings to the  xaxis  argument will allow the quick definition\nof  xlabel ,  xlim ,  xticks ,  xscale ,  xflip , and  xtickfont .  The following are equivalent:  plot ( y ,   xaxis   =   ( \"my label\" ,   ( 0 , 10 ),   0 : 0.5 : 10 ,   : log ,   : flip ,   font ( 20 ,   \"Courier\" )))  plot ( y ,   xlabel   =   \"my label\" , \n         xlims   =   ( 0 , 10 ), \n         xticks   =   0 : 0.5 : 10 , \n         xscale   =   : log , \n         xflip   =   true , \n         xtickfont   =   font ( 20 ,   \"Courier\" ))   Note that  yaxis  and  zaxis  work similarly, and  axis  will apply to all.",
            "title": "axis (and xaxis/yaxis/zaxis)"
        },
        {
            "location": "/attributes/#line",
            "text": "Set attributes corresponding to a series line.  Aliases:  l .  The following are equivalent:  plot ( y ,   line   =   ( : steppre ,   : dot ,   : arrow ,   0.5 ,   4 ,   : red ))  plot ( y ,   seriestype   =   : steppre , \n         linestyle   =   : dot , \n         arrow   =   : arrow , \n         linealpha   =   0.5 , \n         linewidth   =   4 , \n         linecolor   =   : red )",
            "title": "line"
        },
        {
            "location": "/attributes/#fill",
            "text": "Set attributes corresponding to a series fill area.  Aliases:  f ,  area .  The following are equivalent:  plot ( y ,   fill   =   ( 0 ,   0.5 ,   : red ))  plot ( y ,   fillrange   =   0 , \n         fillalpha   =   0.5 , \n         fillcolor   =   : red )",
            "title": "fill"
        },
        {
            "location": "/attributes/#marker",
            "text": "Set attributes corresponding to a series marker.  Aliases:  m ,  mark .  The following are equivalent:  scatter ( y ,   marker   =   ( : hexagon ,   20 ,   0.6 ,   : green ,   stroke ( 3 ,   0.2 ,   : black ,   : dot )))  scatter ( y ,   markershape   =   : hexagon , \n            markersize   =   20 , \n            markeralpha   =   0.6 , \n            markercolor   =   : green , \n            markerstrokewidth   =   3 , \n            markerstrokealpha   =   0.2 , \n            markerstrokecolor   =   : black , \n            markerstrokestyle   =   : dot )",
            "title": "marker"
        },
        {
            "location": "/attributes/#series",
            "text": "These attributes apply to individual series (lines, scatters, heatmaps, etc)  You need a Frames Capable browser to view this content.",
            "title": "Series"
        },
        {
            "location": "/attributes/#plot",
            "text": "These attributes apply to the full Plot.  (A Plot contains a tree-like layout of Subplots)  You need a Frames Capable browser to view this content.",
            "title": "Plot"
        },
        {
            "location": "/attributes/#subplot",
            "text": "These attributes apply to settings for individual Subplots.  You need a Frames Capable browser to view this content.",
            "title": "Subplot"
        },
        {
            "location": "/attributes/#axis",
            "text": "These attributes apply to an individual Axis in a Subplot (for example the  subplot[:xaxis] )  You need a Frames Capable browser to view this content.",
            "title": "Axis"
        },
        {
            "location": "/output/",
            "text": "Output\n\n\nA Plot is only displayed when returned\n (a semicolon will suppress the return), or if explicitly displayed with \ndisplay(plt)\n, \ngui()\n, or by adding \nshow = true\n to your plot command.\n\n\n\nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)\n\n\n\n\nStandalone window\n\n\nCalling \ngui(plt)\n will open a standalone window.  \ngui()\n, like \nplot!(...)\n, applies to the \"current\" Plot.  Returning a Plot object to the REPL is like calling \ngui(plt)\n.\n\n\nJupyter / IJulia\n\n\nPlots are shown inline when returned to a cell.  The default output format can be changed by the \nhtml_output_format\n attribute, with alias \nfmt\n:\n\n\nplot\n(\nrand\n(\n10\n),\n \nfmt\n \n=\n \n:\npng\n)\n\n\n\n\n\n\nJuno / Atom\n\n\nPlots are shown in the Atom PlotPane when possible, either when returned to the console or to an inline code block. At any time, the plot can be opened in a standalone window using the \ngui()\n command. The default behavior can be switched to match the REPL behavior (i.e. opening a standalone window) by setting \nENV[\"PLOTS_USE_ATOM_PLOTPANE\"] = \"false\"\n before loading Plots.\n\n\nNote that javascript-based libraries (for example: PlotlyJS) cannot be shown in the PlotPane due to issues within Atom's internals.\n\n\nsavefig / png\n\n\nSave the most recent plot, choosing file type automatically by the extension.\n\n\nsavefig\n(\nfilename\n)\n\n\n\n\n\n\nThere are also shorthands \npng(fn)\n, etc.  You don't need the file extension for those.",
            "title": "Output"
        },
        {
            "location": "/output/#output",
            "text": "A Plot is only displayed when returned  (a semicolon will suppress the return), or if explicitly displayed with  display(plt) ,  gui() , or by adding  show = true  to your plot command.  \nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)",
            "title": "Output"
        },
        {
            "location": "/output/#standalone-window",
            "text": "Calling  gui(plt)  will open a standalone window.   gui() , like  plot!(...) , applies to the \"current\" Plot.  Returning a Plot object to the REPL is like calling  gui(plt) .",
            "title": "Standalone window"
        },
        {
            "location": "/output/#jupyter-ijulia",
            "text": "Plots are shown inline when returned to a cell.  The default output format can be changed by the  html_output_format  attribute, with alias  fmt :  plot ( rand ( 10 ),   fmt   =   : png )",
            "title": "Jupyter / IJulia"
        },
        {
            "location": "/output/#juno-atom",
            "text": "Plots are shown in the Atom PlotPane when possible, either when returned to the console or to an inline code block. At any time, the plot can be opened in a standalone window using the  gui()  command. The default behavior can be switched to match the REPL behavior (i.e. opening a standalone window) by setting  ENV[\"PLOTS_USE_ATOM_PLOTPANE\"] = \"false\"  before loading Plots.  Note that javascript-based libraries (for example: PlotlyJS) cannot be shown in the PlotPane due to issues within Atom's internals.",
            "title": "Juno / Atom"
        },
        {
            "location": "/output/#savefig-png",
            "text": "Save the most recent plot, choosing file type automatically by the extension.  savefig ( filename )   There are also shorthands  png(fn) , etc.  You don't need the file extension for those.",
            "title": "savefig / png"
        },
        {
            "location": "/backends/",
            "text": "Backends\n\n\nBackends are the lifeblood of Plots, and the diversity between features, approaches, and strengths/weaknesses was \none of the primary reasons that I started this package.\n\n\nFor those who haven't had the pleasure of hacking on 15 different plotting APIs:  First, consider yourself lucky.  However,\nyou will probably have a hard time choosing the right backend for your task at hand.  This document is meant to be a guide and \nintroduction to making that choice.\n\n\nFor the impatient\n\n\nMy favorites: GR for speed, Plotly(JS) for interactivity, PyPlot otherwise.\n\n\n\n\n\n\n\n\nIf you require...\n\n\n... then use...\n\n\n\n\n\n\n\n\n\n\nfeatures\n\n\nPyPlot, Plotly(JS), GR\n\n\n\n\n\n\nspeed\n\n\nGR, InspectDR\n\n\n\n\n\n\ninteractivity\n\n\nPlotly(JS), InspectDR\n\n\n\n\n\n\nbeauty\n\n\nPlotly(JS), PGFPlots\n\n\n\n\n\n\nREPL Plotting\n\n\nUnicodePlots\n\n\n\n\n\n\n3D plots\n\n\nPyPlot, GR, Plotly(JS)\n\n\n\n\n\n\na GUI Window\n\n\nGR, PyPlot, PlotlyJS, InspectDR\n\n\n\n\n\n\na small footprint\n\n\nUnicodePlots, Plotly\n\n\n\n\n\n\nplot+data -> \n.hdf5\n file\n\n\nHDF5\n\n\n\n\n\n\n\n\nOf course nothing in life is that simple.  Likely there are subtle tradeoffs between backends, long hidden bugs, and more excitement.  Don't be shy to try out something new!\n\n\n\n\nPyPlot\n\n\nA Julia wrapper around the popular python package PyPlot (Matplotlib).  It uses PyCall.jl to pass data with minimal overhead.\n\n\n\n\nPros:\n\n\n\n\nTons of functionality\n\n\n2D and 3D\n\n\nMature library\n\n\nStandalone or inline\n\n\nWell supported in Plots\n\n\n\n\nCons:\n\n\n\n\nUses python\n\n\nDependencies frequently cause setup issues\n\n\nInconsistent output depending on Matplotlib version\n\n\n\n\nPrimary author: Steven G Johnson (@stevengj)\n\n\nPlotly / PlotlyJS\n\n\nThese are treated as separate backends, though they share much of the code and use the Plotly javascript API.  \nplotly()\n is the only dependency-free plotting option,\nas the required javascript is bundled with Plots.  It can create inline plots in IJulia, or open standalone browser windows when run from the Julia REPL.\n\n\nplotlyjs()\n is the preferred option, and taps into the great functionality of Spencer Lyon's PlotlyJS.jl.  Inline IJulia plots can be updated from any cell... something that\nmakes this backend stand out.  From the Julia REPL, it taps into Blink.jl and Electron to plot within a standalone GUI window... also very cool. Also, PlotlyJS supports saving the output to more formats than Plotly, such as EPS and PDF, and thus is the recommended version of Plotly for developing publication-quality figures.\n\n\n\n\nPros:\n\n\n\n\nTons of functionality\n\n\n2D and 3D\n\n\nMature library\n\n\nInteractivity (even when inline)\n\n\nStandalone or inline\n\n\n\n\nCons:\n\n\n\n\nNo custom shapes\n\n\nJSON may limit performance\n\n\n\n\nPrimary PlotlyJS.jl author: Spencer Lyon (@spencerlyon2)\n\n\nGR\n\n\nSuper fast with lots of plot types.  Still actively developed and improving daily.\n\n\n\n\nPros:\n\n\n\n\nSpeed\n\n\n2D and 3D\n\n\nStandalone or inline\n\n\n\n\nCons:\n\n\n\n\nLimited interactivity\n\n\nPlots integration is still a work in progress\n\n\n\n\nPrimary author: Josef Heinen (@jheinen)\n\n\nUnicodePlots\n\n\nSimple and lightweight.  Plot directly in your terminal.  You won't produce anything publication quality, but for a quick look at your data it is awesome.\n\n\n\n\nPros:\n\n\n\n\nMinimal dependencies\n\n\nLightweight\n\n\nFast\n\n\nREPL plotting\n\n\n\n\nCons:\n\n\n\n\nLimited functionality\n\n\n\n\nPrimary author: Christof Stocker (@Evizero)\n\n\nPGFPlots\n\n\nLaTeX plotting, based on PGF/TikZ.\n\n\n\n\nPros:\n\n\n\n\nNice looking plots\n\n\nLots of functionality (though the code is still WIP)\n\n\n\n\nCons:\n\n\n\n\nTricky to install\n\n\nHeavy-weight dependencies\n\n\n\n\nAuthors:\n\n\n\n\nPGFPlots: Christian Feuersanger\n\n\nPGFPlots.jl: Mykel Kochenderfer (@mykelk),  Louis Dressel (@dressel), and others\n\n\nPlots <--> PGFPlots link code: Patrick Kofod Mogensen (@pkofod)\n\n\n\n\nInspectDR\n\n\nFast plotting with a responsive GUI (optional).  Target: Quickly identify design/simulation issues & glitches in order to shorten design iterations.\n\n\n \n\n\nPros:\n\n\n\n\nRelatively short load times / time to first plot.\n\n\nInteractive mouse/keybindings.\n\n\nFast & simple way to pan/zoom into data.\n\n\nDrag & drop \u0394-markers (Measure/display \u0394x, \u0394y & slope).\n\n\nDesigned with larger datasets in mind.\n\n\nResponsive even with moderate (>200k points) datasets.\n\n\nConfirmed to handle 2GB datsets with reasonable speed on older desktop running Windows 7 (drag+pan of data area highly discouraged).\n\n\n\n\nCons:\n\n\n\n\nMostly limited to 2D line/scatter plots\n\n\n\n\nPrimary author: MA Laforge (@ma-laforge)\n\n\nHDF5\n (HDF5-Plots)\n\n\nWrite plot + data to a \nsingle\n \nHDF5\n file using a human-readable structure that can easily be reverse-engineered.\n\n\n\n\nWrite to .hdf5 file\n\n\nhdf5() #Select HDF5-Plots \"backend\"\np = plot(...) #Construct plot as usual\nPlots.hdf5plot_write(p, \"plotsave.hdf5\")\n\n\n\n\n\nRead from .hdf5 file\n\n\npyplot() #Must first select some backend\npread = Plots.hdf5plot_read(\"plotsave.hdf5\")\ndisplay(pread)\n\n\n\n\n\nPros:\n\n\n\n\nOpen, standard file format for complex datasets.\n\n\nHuman readble (using \nHDF5view\n).\n\n\nSave plot + data to a single binary file.\n\n\n(Re)-render plots at a later time using your favourite backend(s).\n\n\n\n\nCons:\n\n\n\n\nCurrently missing support for \nSeriesAnnotations\n & \nGridLayout\n.\n\n\n(Please open an \"issue\" if you have a need).\n\n\nNot yet designed for backwards compatibility (no proper versionning).\n\n\nTherefore not truly adequate for archival purposes at the moment.\n\n\nCurrently implemented as a \"backend\" to avoid adding dependencies to \nPlots.jl\n.\n\n\n\n\nPrimary author: MA Laforge (@ma-laforge)\n\n\n\n\nThe future: works in progress\n\n\nGLVisualize\n\n\nA really awesome 2D/3D visualization library written in Julia and OpenGL.  It is feature-packed and fast, and author Simon Danisch has put a ton of energy into its development.  I'm very excited for the day that this is cleanly wrapped.\n\n\n\n\nDeprecated backends\n\n\nGadfly\n\n\nA Julia implementation inspired by the \"Grammar of Graphics\".\n\n\nPros:\n\n\n\n\nClean look\n\n\nLots of features\n\n\nFlexible when combined with Compose.jl (inset plots, etc)\n\n\n\n\nCons:\n\n\n\n\nDo not support 3D\n\n\nSlow time-to-first-plot\n\n\nLots of dependencies\n\n\nNo interactivity\n\n\n\n\nPrimary author: Daniel C Jones\n\n\nImmerse\n\n\nBuilt on top of Gadfly, Immerse adds some interactivity and a standalone GUI window, including zoom/pan and a cool \"point lasso\" tool to save Julia vectors with the selected data points.\n\n\nPros:\n\n\n\n\nSame as Gadfly\n\n\nInteractivity\n\n\nStandalone or inline\n\n\nLasso functionality\n\n\n\n\nCons:\n\n\n\n\nSame as Gadfly\n\n\n\n\nPrimary author: Tim Holy\n\n\nQwt\n\n\nMy package which wraps PyQwt.  Similar to PyPlot, it uses PyCall to convert calls to python.  Though Qwt.jl was the \"first draft\" of Plots, the functionality is superceded by other backends, and it's not worth my time to maintain.\n\n\nPrimary author: Thomas Breloff\n\n\nBokeh\n\n\nUnfinished, but very similar to PlotlyJS... use that instead.\n\n\nWinston\n\n\nFunctionality incomplete... I never finished wrapping it, and I don't think it offers anything beyond other backends.  However, the plots are clean looking and it's relatively fast.",
            "title": "Backends"
        },
        {
            "location": "/backends/#backends",
            "text": "Backends are the lifeblood of Plots, and the diversity between features, approaches, and strengths/weaknesses was \none of the primary reasons that I started this package.  For those who haven't had the pleasure of hacking on 15 different plotting APIs:  First, consider yourself lucky.  However,\nyou will probably have a hard time choosing the right backend for your task at hand.  This document is meant to be a guide and \nintroduction to making that choice.",
            "title": "Backends"
        },
        {
            "location": "/backends/#for-the-impatient",
            "text": "My favorites: GR for speed, Plotly(JS) for interactivity, PyPlot otherwise.     If you require...  ... then use...      features  PyPlot, Plotly(JS), GR    speed  GR, InspectDR    interactivity  Plotly(JS), InspectDR    beauty  Plotly(JS), PGFPlots    REPL Plotting  UnicodePlots    3D plots  PyPlot, GR, Plotly(JS)    a GUI Window  GR, PyPlot, PlotlyJS, InspectDR    a small footprint  UnicodePlots, Plotly    plot+data ->  .hdf5  file  HDF5     Of course nothing in life is that simple.  Likely there are subtle tradeoffs between backends, long hidden bugs, and more excitement.  Don't be shy to try out something new!",
            "title": "For the impatient"
        },
        {
            "location": "/backends/#pyplot",
            "text": "A Julia wrapper around the popular python package PyPlot (Matplotlib).  It uses PyCall.jl to pass data with minimal overhead.   Pros:   Tons of functionality  2D and 3D  Mature library  Standalone or inline  Well supported in Plots   Cons:   Uses python  Dependencies frequently cause setup issues  Inconsistent output depending on Matplotlib version   Primary author: Steven G Johnson (@stevengj)",
            "title": "PyPlot"
        },
        {
            "location": "/backends/#plotly-plotlyjs",
            "text": "These are treated as separate backends, though they share much of the code and use the Plotly javascript API.   plotly()  is the only dependency-free plotting option,\nas the required javascript is bundled with Plots.  It can create inline plots in IJulia, or open standalone browser windows when run from the Julia REPL.  plotlyjs()  is the preferred option, and taps into the great functionality of Spencer Lyon's PlotlyJS.jl.  Inline IJulia plots can be updated from any cell... something that\nmakes this backend stand out.  From the Julia REPL, it taps into Blink.jl and Electron to plot within a standalone GUI window... also very cool. Also, PlotlyJS supports saving the output to more formats than Plotly, such as EPS and PDF, and thus is the recommended version of Plotly for developing publication-quality figures.   Pros:   Tons of functionality  2D and 3D  Mature library  Interactivity (even when inline)  Standalone or inline   Cons:   No custom shapes  JSON may limit performance   Primary PlotlyJS.jl author: Spencer Lyon (@spencerlyon2)",
            "title": "Plotly / PlotlyJS"
        },
        {
            "location": "/backends/#gr",
            "text": "Super fast with lots of plot types.  Still actively developed and improving daily.   Pros:   Speed  2D and 3D  Standalone or inline   Cons:   Limited interactivity  Plots integration is still a work in progress   Primary author: Josef Heinen (@jheinen)",
            "title": "GR"
        },
        {
            "location": "/backends/#unicodeplots",
            "text": "Simple and lightweight.  Plot directly in your terminal.  You won't produce anything publication quality, but for a quick look at your data it is awesome.   Pros:   Minimal dependencies  Lightweight  Fast  REPL plotting   Cons:   Limited functionality   Primary author: Christof Stocker (@Evizero)",
            "title": "UnicodePlots"
        },
        {
            "location": "/backends/#pgfplots",
            "text": "LaTeX plotting, based on PGF/TikZ.   Pros:   Nice looking plots  Lots of functionality (though the code is still WIP)   Cons:   Tricky to install  Heavy-weight dependencies   Authors:   PGFPlots: Christian Feuersanger  PGFPlots.jl: Mykel Kochenderfer (@mykelk),  Louis Dressel (@dressel), and others  Plots <--> PGFPlots link code: Patrick Kofod Mogensen (@pkofod)",
            "title": "PGFPlots"
        },
        {
            "location": "/backends/#inspectdr",
            "text": "Fast plotting with a responsive GUI (optional).  Target: Quickly identify design/simulation issues & glitches in order to shorten design iterations.     Pros:   Relatively short load times / time to first plot.  Interactive mouse/keybindings.  Fast & simple way to pan/zoom into data.  Drag & drop \u0394-markers (Measure/display \u0394x, \u0394y & slope).  Designed with larger datasets in mind.  Responsive even with moderate (>200k points) datasets.  Confirmed to handle 2GB datsets with reasonable speed on older desktop running Windows 7 (drag+pan of data area highly discouraged).   Cons:   Mostly limited to 2D line/scatter plots   Primary author: MA Laforge (@ma-laforge)",
            "title": "InspectDR"
        },
        {
            "location": "/backends/#hdf5-hdf5-plots",
            "text": "Write plot + data to a  single   HDF5  file using a human-readable structure that can easily be reverse-engineered.   Write to .hdf5 file  hdf5() #Select HDF5-Plots \"backend\"\np = plot(...) #Construct plot as usual\nPlots.hdf5plot_write(p, \"plotsave.hdf5\")  Read from .hdf5 file  pyplot() #Must first select some backend\npread = Plots.hdf5plot_read(\"plotsave.hdf5\")\ndisplay(pread)  Pros:   Open, standard file format for complex datasets.  Human readble (using  HDF5view ).  Save plot + data to a single binary file.  (Re)-render plots at a later time using your favourite backend(s).   Cons:   Currently missing support for  SeriesAnnotations  &  GridLayout .  (Please open an \"issue\" if you have a need).  Not yet designed for backwards compatibility (no proper versionning).  Therefore not truly adequate for archival purposes at the moment.  Currently implemented as a \"backend\" to avoid adding dependencies to  Plots.jl .   Primary author: MA Laforge (@ma-laforge)",
            "title": "HDF5 (HDF5-Plots)"
        },
        {
            "location": "/backends/#the-future-works-in-progress",
            "text": "",
            "title": "The future: works in progress"
        },
        {
            "location": "/backends/#glvisualize",
            "text": "A really awesome 2D/3D visualization library written in Julia and OpenGL.  It is feature-packed and fast, and author Simon Danisch has put a ton of energy into its development.  I'm very excited for the day that this is cleanly wrapped.",
            "title": "GLVisualize"
        },
        {
            "location": "/backends/#deprecated-backends",
            "text": "",
            "title": "Deprecated backends"
        },
        {
            "location": "/backends/#gadfly",
            "text": "A Julia implementation inspired by the \"Grammar of Graphics\".  Pros:   Clean look  Lots of features  Flexible when combined with Compose.jl (inset plots, etc)   Cons:   Do not support 3D  Slow time-to-first-plot  Lots of dependencies  No interactivity   Primary author: Daniel C Jones",
            "title": "Gadfly"
        },
        {
            "location": "/backends/#immerse",
            "text": "Built on top of Gadfly, Immerse adds some interactivity and a standalone GUI window, including zoom/pan and a cool \"point lasso\" tool to save Julia vectors with the selected data points.  Pros:   Same as Gadfly  Interactivity  Standalone or inline  Lasso functionality   Cons:   Same as Gadfly   Primary author: Tim Holy",
            "title": "Immerse"
        },
        {
            "location": "/backends/#qwt",
            "text": "My package which wraps PyQwt.  Similar to PyPlot, it uses PyCall to convert calls to python.  Though Qwt.jl was the \"first draft\" of Plots, the functionality is superceded by other backends, and it's not worth my time to maintain.  Primary author: Thomas Breloff",
            "title": "Qwt"
        },
        {
            "location": "/backends/#bokeh",
            "text": "Unfinished, but very similar to PlotlyJS... use that instead.",
            "title": "Bokeh"
        },
        {
            "location": "/backends/#winston",
            "text": "Functionality incomplete... I never finished wrapping it, and I don't think it offers anything beyond other backends.  However, the plots are clean looking and it's relatively fast.",
            "title": "Winston"
        },
        {
            "location": "/colors/",
            "text": "Colors\n\n\nThere are many color attributes, for lines, fills, markers, backgrounds, and foregrounds.  Many colors follow a hierarchy... \nlinecolor\n gets its value from \nseriescolor\n, for example, unless you override the value.  This allows for you to simply set precisely what you want, without lots of boilerplate.\n\n\nColor attributes will except many different types:\n\n\n\n\nSymbol\ns or \nString\ns will be passed to \nColors.parse(Colorant, c)\n, so \n:red\n is equivalent to \ncolorant\"red\"\n\n\nfalse\n or \nnothing\n will be converted to an invisible \nRGBA(0,0,0,0)\n\n\nAny \nColors.Colorant\n, with or without alpha/opacity\n\n\nAny \nPlots.ColorScheme\n, which includes \nColorVector\n, \nColorGradient\n, etc\n\n\n\n\nIn addition, there is an extensive facility for selecting and generating color maps/gradients.\n\n\n\n\nA valid Symbol: \n:inferno\n (the default), \n:heat\n, \n:blues\n, etc\n\n\nA list of colors (or anything that can be converted to a color)\n\n\nA pre-built \nColorGradient\n, which can be constructed with the \ncgrad\n helper function.  See \nthis short tutorial\n for example usage.\n\n\n\n\n\n\nSeries Colors\n\n\nFor series, there are a few attributes to know:\n\n\n\n\nseriescolor\n: Not used directly, but defines the base color for the series\n\n\nlinecolor\n: Color of paths\n\n\nfillcolor\n: Color of area fill\n\n\nmarkercolor\n: Color of the interior of markers and shapes\n\n\nmarkerstrokecolor\n: Color of the border/stroke of markers and shapes\n\n\n\n\nseriescolor\n defaults to \n:auto\n, and gets assigned a color from the \ncolor_palette\n based on its index in the subplot.  By default, the other colors \n:match\n.  (See the table below)\n\n\n\n\n\n\n\n\nThis color...\n\n\nmatches this color...\n\n\n\n\n\n\n\n\n\n\nlinecolor\n\n\nseriescolor\n\n\n\n\n\n\nfillcolor\n\n\nseriescolor\n\n\n\n\n\n\nmarkercolor\n\n\nseriescolor\n\n\n\n\n\n\nmarkerstrokecolor\n\n\nforeground_color_subplot\n\n\n\n\n\n\n\n\nNote: each of these attributes have a corresponding alpha override: \nseriesalpha\n, \nlinealpha\n, \nfillalpha\n, \nmarkeralpha\n, and \nmarkerstrokealpha\n.  They are optional, and you can still give alpha information as part of an \nColors.RGBA\n.\n\n\nNote: in some contexts, and when the user hasn't set a value, the \nlinecolor\n or \nmarkerstrokecolor\n may be overridden.\n\n\n\n\nForeground/Background\n\n\nForeground and background colors work similarly:\n\n\n\n\n\n\n\n\nThis color...\n\n\nmatches this color...\n\n\n\n\n\n\n\n\n\n\nbackground_color_outside\n\n\nbackground_color\n\n\n\n\n\n\nbackground_color_subplot\n\n\nbackground_color\n\n\n\n\n\n\nbackground_color_legend\n\n\nbackground_color_subplot\n\n\n\n\n\n\nbackground_color_inside\n\n\nbackground_color_subplot\n\n\n\n\n\n\nforeground_color_subplot\n\n\nforeground_color\n\n\n\n\n\n\nforeground_color_legend\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_grid\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_title\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_axis\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_border\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_guide\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_text\n\n\nforeground_color_subplot\n\n\n\n\n\n\n\n\n\n\nMisc\n\n\n\n\nline_z\n and \nmarker_z\n parameters will map data values into a ColorGradient value\n\n\ncolor_palette\n determines the colors assigned when \nseriescolor == :auto\n:\n\n\nIf passed a vector of colors, it will force cycling of those colors\n\n\nIf passed a gradient, it will infinitely draw unique colors from that gradient, attempting to spread them out",
            "title": "Colors"
        },
        {
            "location": "/colors/#colors",
            "text": "There are many color attributes, for lines, fills, markers, backgrounds, and foregrounds.  Many colors follow a hierarchy...  linecolor  gets its value from  seriescolor , for example, unless you override the value.  This allows for you to simply set precisely what you want, without lots of boilerplate.  Color attributes will except many different types:   Symbol s or  String s will be passed to  Colors.parse(Colorant, c) , so  :red  is equivalent to  colorant\"red\"  false  or  nothing  will be converted to an invisible  RGBA(0,0,0,0)  Any  Colors.Colorant , with or without alpha/opacity  Any  Plots.ColorScheme , which includes  ColorVector ,  ColorGradient , etc   In addition, there is an extensive facility for selecting and generating color maps/gradients.   A valid Symbol:  :inferno  (the default),  :heat ,  :blues , etc  A list of colors (or anything that can be converted to a color)  A pre-built  ColorGradient , which can be constructed with the  cgrad  helper function.  See  this short tutorial  for example usage.",
            "title": "Colors"
        },
        {
            "location": "/colors/#series-colors",
            "text": "For series, there are a few attributes to know:   seriescolor : Not used directly, but defines the base color for the series  linecolor : Color of paths  fillcolor : Color of area fill  markercolor : Color of the interior of markers and shapes  markerstrokecolor : Color of the border/stroke of markers and shapes   seriescolor  defaults to  :auto , and gets assigned a color from the  color_palette  based on its index in the subplot.  By default, the other colors  :match .  (See the table below)     This color...  matches this color...      linecolor  seriescolor    fillcolor  seriescolor    markercolor  seriescolor    markerstrokecolor  foreground_color_subplot     Note: each of these attributes have a corresponding alpha override:  seriesalpha ,  linealpha ,  fillalpha ,  markeralpha , and  markerstrokealpha .  They are optional, and you can still give alpha information as part of an  Colors.RGBA .  Note: in some contexts, and when the user hasn't set a value, the  linecolor  or  markerstrokecolor  may be overridden.",
            "title": "Series Colors"
        },
        {
            "location": "/colors/#foregroundbackground",
            "text": "Foreground and background colors work similarly:     This color...  matches this color...      background_color_outside  background_color    background_color_subplot  background_color    background_color_legend  background_color_subplot    background_color_inside  background_color_subplot    foreground_color_subplot  foreground_color    foreground_color_legend  foreground_color_subplot    foreground_color_grid  foreground_color_subplot    foreground_color_title  foreground_color_subplot    foreground_color_axis  foreground_color_subplot    foreground_color_border  foreground_color_subplot    foreground_color_guide  foreground_color_subplot    foreground_color_text  foreground_color_subplot",
            "title": "Foreground/Background"
        },
        {
            "location": "/colors/#misc",
            "text": "line_z  and  marker_z  parameters will map data values into a ColorGradient value  color_palette  determines the colors assigned when  seriescolor == :auto :  If passed a vector of colors, it will force cycling of those colors  If passed a gradient, it will infinitely draw unique colors from that gradient, attempting to spread them out",
            "title": "Misc"
        },
        {
            "location": "/animations/",
            "text": "Animations\n\n\nAnimations are created in 3 steps:\n\n\n\n\nInitialize an \nAnimation\n object.\n\n\nSave each frame of the animation with \nframe(anim)\n.\n\n\nConvert the frames to an animated gif with \ngif(anim, filename, fps=15)\n\n\n\n\n\nTip: the convenience macros `@gif` and `@animate` simplify this code immensely.  See the \nhome page\n for examples of the short version, or\nthe \npyplot example\n for the long version.\n\n\n\n\n\n\nConvenience macros\n\n\nThere are two macros for varying levels of convenience in creating animations: \n@animate\n and \n@gif\n.  The main difference is that \n@animate\n will return an \nAnimation\n object for later processing, and \n@gif\n will create an animated gif file (and display it when returned to an IJulia cell).\n\n\nUse \n@gif\n for simple, one-off animations that you want to view immediately.  Use \n@animate\n for anything more complex.  Constructing \nAnimation\n objects can be done when you need full control of the life-cycle of the animation (usually unnecessary though).\n\n\nExamples:\n\n\nanim\n \n=\n \n@animate\n \nfor\n \ni\n=\n1\n:\n100\n\n    \nplot\n(\n...\n)\n\n\nend\n\n\ngif\n(\nanim\n,\n \n\"/tmp/anim_fps15.gif\"\n,\n \nfps\n \n=\n \n15\n)\n\n\ngif\n(\nanim\n,\n \n\"/tmp/anim_fps30.gif\"\n,\n \nfps\n \n=\n \n30\n)\n\n\n\n\n\n\nThe \nevery\n flag will only save a frame \"every N iterations\":\n\n\n@gif\n \nfor\n \ni\n=\n1\n:\n100\n\n    \nplot\n(\n...\n)\n\n\nend\n \nevery\n \n10\n\n\n\n\n\n\nThe \nwhen\n flag will only save a frame \"when the expression is true\"\n\n\n@gif\n \nfor\n \ni\n=\n1\n:\n100\n\n    \nplot\n(\n...\n)\n\n\nend\n \nwhen\n \ni\n \n>\n \n50\n \n&&\n \nmod1\n(\ni\n,\n \n10\n)\n \n==\n \n5\n\n\n\n\n\n\nCustom Iterators\n\n\nThe newly added \nanimate\n method allows you to pass an arbitrary iterator which returns\nthe \"input data\" for plotting each frame of an animation.  As an example, we'll use\n\nIterators.repeatedly\n to give us an iterator which returns a random vector on each iteration:\n\n\nusing\n \nPlots\n,\n \nIterators\n\n\nitr\n \n=\n \nrepeatedly\n(()\n->\nrand\n(\n10\n),\n \n20\n)\n\n\nanimate\n(\nitr\n,\n \nylims\n=\n(\n0\n,\n1\n),\n \nc\n=:\nred\n,\n \nfps\n=\n5\n)",
            "title": "Animations"
        },
        {
            "location": "/animations/#animations",
            "text": "Animations are created in 3 steps:   Initialize an  Animation  object.  Save each frame of the animation with  frame(anim) .  Convert the frames to an animated gif with  gif(anim, filename, fps=15)   \nTip: the convenience macros `@gif` and `@animate` simplify this code immensely.  See the  home page  for examples of the short version, or\nthe  pyplot example  for the long version.",
            "title": "Animations"
        },
        {
            "location": "/animations/#convenience-macros",
            "text": "There are two macros for varying levels of convenience in creating animations:  @animate  and  @gif .  The main difference is that  @animate  will return an  Animation  object for later processing, and  @gif  will create an animated gif file (and display it when returned to an IJulia cell).  Use  @gif  for simple, one-off animations that you want to view immediately.  Use  @animate  for anything more complex.  Constructing  Animation  objects can be done when you need full control of the life-cycle of the animation (usually unnecessary though).  Examples:  anim   =   @animate   for   i = 1 : 100 \n     plot ( ... )  end  gif ( anim ,   \"/tmp/anim_fps15.gif\" ,   fps   =   15 )  gif ( anim ,   \"/tmp/anim_fps30.gif\" ,   fps   =   30 )   The  every  flag will only save a frame \"every N iterations\":  @gif   for   i = 1 : 100 \n     plot ( ... )  end   every   10   The  when  flag will only save a frame \"when the expression is true\"  @gif   for   i = 1 : 100 \n     plot ( ... )  end   when   i   >   50   &&   mod1 ( i ,   10 )   ==   5",
            "title": "Convenience macros"
        },
        {
            "location": "/animations/#custom-iterators",
            "text": "The newly added  animate  method allows you to pass an arbitrary iterator which returns\nthe \"input data\" for plotting each frame of an animation.  As an example, we'll use Iterators.repeatedly  to give us an iterator which returns a random vector on each iteration:  using   Plots ,   Iterators  itr   =   repeatedly (() -> rand ( 10 ),   20 )  animate ( itr ,   ylims = ( 0 , 1 ),   c =: red ,   fps = 5 )",
            "title": "Custom Iterators"
        },
        {
            "location": "/learning/",
            "text": "Tutorials\n\n\n\n\nMachine Learning and Visualization in Julia\n\n\nQuant Econ tutorial\n\n\nSection from Chris Rackauckas' awesome tutorial\n\n\nPlotting section of a Julia wiki\n\n\n\n\nDemos, Examples and Notebooks\n\n\n\n\nVisualizing Graphs in Julia using Plots and PlotRecipes\n\n\nExamplePlots\n\n\nSome notebooks\n\n\n\n\nVideo tutorials\n\n\nPlots with Plots - JuliaCon 2016\n\n\n\n\n\nEcosystem and Pipeline\n\n\nhttp://www.breloff.com/plots-video/\n\n\n\n\n\nPlots in the wild\n\n\nTODO (See the \necosystem\n)",
            "title": "Learning"
        },
        {
            "location": "/learning/#tutorials",
            "text": "Machine Learning and Visualization in Julia  Quant Econ tutorial  Section from Chris Rackauckas' awesome tutorial  Plotting section of a Julia wiki",
            "title": "Tutorials"
        },
        {
            "location": "/learning/#demos-examples-and-notebooks",
            "text": "Visualizing Graphs in Julia using Plots and PlotRecipes  ExamplePlots  Some notebooks",
            "title": "Demos, Examples and Notebooks"
        },
        {
            "location": "/learning/#video-tutorials",
            "text": "",
            "title": "Video tutorials"
        },
        {
            "location": "/learning/#plots-with-plots-juliacon-2016",
            "text": "",
            "title": "Plots with Plots - JuliaCon 2016"
        },
        {
            "location": "/learning/#ecosystem-and-pipeline",
            "text": "http://www.breloff.com/plots-video/",
            "title": "Ecosystem and Pipeline"
        },
        {
            "location": "/learning/#plots-in-the-wild",
            "text": "TODO (See the  ecosystem )",
            "title": "Plots in the wild"
        },
        {
            "location": "/contributing/",
            "text": "This is a guide to contributing to Plots and the surrounding ecosystem.  Plots is a complex and far-reaching suite of software components, and as such will be most effective when the community contributes their own expertise, knowledge, perspective, and effort.  The document is roughly broken up into the following categories, and after reading this introduction you should feel comfortable skipping to the section(s) that interest you the most:\n\n\n\n\nThe JuliaPlots Organization\n: Packages and dependencies\n\n\nChoosing a Project\n: Fix bugs, add features, create recipes\n\n\nKey Design Principles\n: Design goals and considerations\n\n\nCode Organization\n: Where to look when implementing new features\n\n\nGit-fu (or... the mechanics of contributing)\n: Git (how to commit/push), Github (how to submit a PR), Testing (VisualRegressionTests, Travis)\n\n\n\n\nWhen in doubt, use this handy dandy logic designed by a \nlegendary open source guru\n...\n\n\n\n\n\n\nThe JuliaPlots Organization\n\n\nJuliaPlots\n is the home for all things Plots.  It was founded by \nTom Breloff\n, and extended through many contributions from \nmembers\n and others.  The first step in contributing will be to understand which package(s) are appropriate destinations for your code.\n\n\nPlots\n\n\nThis is the core package for:\n\n\n\n\nDefinitions of \nplot\n/\nplot!\n\n\nThe \ncore processing pipeline\n\n\nBase \nrecipes\n for \npath\n, \nscatter\n, \nbar\n, and many others\n\n\nGeneric \noutput\n methods\n\n\nGeneric \nlayout\n methods\n\n\nGeneric \nanimation\n methods\n\n\nGeneric types: Plot, Subplot, Axis, Series, ...\n\n\nConveniences: \ngetindex\n/\nsetindex\n, \npush!\n/\nappend!\n, \nunzip\n, \ncycle\n, ...\n\n\n\n\nThis package depends on RecipesBase, PlotUtils, and PlotThemes.  When contributing new functionality/features, you should make best efforts to find a more appropriate home (StatPlots, PlotUtils, etc) than contributing to core Plots.  In general, the push has been to reduce the size and scope of Plots, when possible, and move features to other packages.\n\n\nBackends\n\n\nIn Julia versions v0.5 and earlier, backend code (such as code linking Plots with GR) lived in the \nPlots/src/backends\n directory.  As such, backend code should be contributed to core Plots.\n\n\nStarting with v0.6, the backend code will live in separate repos, and loaded on demand.  For example, the GR backend is being developed at \nPlotsGR\n.  Users targeting v0.6 and later should contribute to the respective backend package \"Plots[backend].jl\".\n\n\nNote: As of 2/22/17, the \nreorg\n branch of Plots is needed for compatibility with the new backend repos.  This will be merged into the master branch sometime after the release of v0.6.\n\n\nThis redesign will help with improved support for precompilation, and a cleaner separation of \"generic plotting\" development and \"backend-specific\" development.\n\n\nPlotDocs\n\n\nPlotDocs is the home of this documentation.  The documentation is built using the \"material\" theme in \"mkdocs\".  For those contributing documentation (to the \ndocs\n directory of PlotDocs), it must be subsequently built and deployed using the following instructions:\n\n\n# Note: the site is built inside the PlotDocs.jl repo, but then deployed to the JuliaPlots organization page\n\n# To build, run from inside the PlotDocs directory:\n#     mkdocs build --clean\n# (optional) Make the githubio remote point to JuliaPlots/juliaplots.github.io:\n#     git remote add githubio git@github.com:JuliaPlots/juliaplots.github.io.git\n# Add files, commit, then push:\n#     git push origin master\n# Push just the site directory to the master branch of githubio\n#     git subtree push --prefix site githubio master\n\n\n\n\n\nRecipesBase\n\n\nSeldom updated, but essential.  This is the package that you would depend on to create third-party recipes.  It contains the bare minimum to define new recipes.\n\n\nPlotUtils\n\n\nComponents that could be used for other (non-Plots) packages.  Anything that is sufficiently generic and useful could be contributed here.\n\n\n\n\nColor (conversions, construction, conveniences)\n\n\nColor gradients/maps\n\n\nTick computation\n\n\n\n\nPlotThemes\n\n\nVisual themes (i.e. attribute defaults) such as \"dark\", \"orange\", etc.\n\n\nStatPlots\n\n\nAn extension of Plots: Statistical plotting and tabular data.  Complex histograms and densities, correlation plots, and support for DataFrames.  Anything related to stats or special handling for table-like data should live here.\n\n\nPlotRecipes\n\n\nAn extension of StatPlots: Graphs, maps, and more.  If it's not a \"base recipe\", and also not clearly \"statistical\" in nature, then this package might be a good home.\n\n\nMLPlots\n\n\nAn extension of PlotRecipes, geared toward Machine Learning applications: neural nets, spike trains, ROC curves, and more.\n\n\nGGPlots\n\n\nA prototype API/interface for \"Grammar of Graphics\" style plotting.  This likely wouldn't add actual functionality, but would give users coming from R/ggplot2 a simple way to avoid Gadfly.  I (Tom) wrote the prototype to show how easy it is, but since I dislike GoG-style, I never finished it.  Completing this package would be a great self-contained project for interested parties.\n\n\n\n\nChoosing a Project\n\n\nFor people new to Plots, the first step should be to read (and reread) the documentation.  Code up some examples, play with the attributes, and try out multiple backends.  It's really hard to contribute to a project that you don't know how to use.\n\n\nBeginner Project Ideas\n\n\n\n\nCreate a new recipe\n: Preferably something you care about.  Maybe you want custom overlays of heatmaps and scatters?  Maybe you have an input format that isn't currently supported?  Make a recipe for it so you can just \nplot(thing)\n.\n\n\nFix bugs\n: There are many \"bugs\" which are specific to one backend, or incorrectly implement features that are infrequently used.  Some ideas can be found in the \nissues marked easy\n.\n\n\nAdd recipes to external packages\n: By depending on RecipesBase, a package can define a recipe for their custom types.  Submit a PR to a package you care about that adds a recipe for that package.  For example, see \nthis PR to add OHLC plots for TimeSeries.jl\n.\n\n\n\n\nIntermediate Project Ideas\n\n\n\n\nImprove your favorite backend\n: There are many missing features and other improvements that can be made to individual backends.  Most issues specific to a backend have a \nspecial tag\n.\n\n\nHelp with documentation\n: This could come in the form of improved descriptions, additional examples, or full tutorials.  Please contribute improvements to \nPlotDocs\n.\n\n\nHelp with the v0.6 reorganization\n: The \nreorg\n requires the annoying effort of creating new repos (PlotsPyPlot, PlotsPlotlyJS, etc) that hold the backend code.  I consider this intermediate because you need to know a little about Plots and git, but it's fairly straightforward to follow the model of PlotsGR.\n\n\nExpand StatPlots functionality\n:  qqplot, DataStreams, or anything else you can think of.\n\n\n\n\nAdvanced Project Ideas\n\n\n\n\nColorBar redesign\n: Colorbars \nneed serious love\n... this would likely require a new Colorbar type that links with the appropriate Series object(s) and is independent during subplot layout.  We want to allow many series (possibly from multiple subplots) to use the same clims and to share a colorbar, or have multiple colorbars that can be flexibly positioned.\n\n\nPlotSpec redesign\n: This \nlong standing redesign proposal\n could allow generic serialization/deserialization of Plot data and attributes, as well as some improvements/optimizations when mutating plots.  For example, we could lazily compute attribute values, and intelligently flag them as \"dirty\" when they change, allowing backends to skip much of the wasted processing and unnecessary rebuilding that currently occurs.\n\n\nImprove graph recipes\n: Lots to do here: clean up visuals, improve edge drawing, implement \nlayout algorithms\n, and much more.\n\n\n\n\n\n\nKey Design Principles\n\n\nFlexible and generic... these are the core principles underlying Plots development, and also tend to cause confusion when users laser-focus on their specific use case.\n\n\nI (Tom) have painstakingly designed the core logic to support nearly any use case that exists or may exist.  I don't pretend to know how you want to use Plots, or what type of data you might pass in, or what sort of recipe you may want to apply.  As such, I try to avoid unnecessary restriction of types, or forced conversions, or many other pitfalls of limited visualization frameworks.  The result is a highly modular framework which is limited by your imagination.\n\n\nWhen contributing new features to Plots (or the surrounding ecosystem), you should strive for this mentality as well.  New features should be left as generic as possible, while avoiding obvious feature clash.\n\n\nAs an example, you may want a new recipe that shows a histogram when passed Float64 numbers, but shows counts of every unique value for strings.  So you make a recipe that works perfectly for your purpose:\n\n\nusing\n \nPlots\n,\n \nStatsBase\n\n\ngr\n(\nsize\n=\n(\n300\n,\n300\n),\n \nleg\n=\nfalse\n)\n\n\n\n@userplot\n \nMyCount\n\n\n@recipe\n \nfunction\n \nf\n(\nmc\n::\nMyCount\n)\n\n    \n# get the array from the args field\n\n    \narr\n \n=\n \nmc\n.\nargs\n[\n1\n]\n\n\n    \nT\n \n=\n \ntypeof\n(\narr\n)\n\n    \nif\n \nT\n.\nparameters\n[\n1\n]\n \n==\n \nFloat64\n\n        \nseriestype\n \n:=\n \n:\nhistogram\n\n        \narr\n\n    \nelse\n\n        \nseriestype\n \n:=\n \n:\nbar\n\n        \ncm\n \n=\n \ncountmap\n(\narr\n)\n\n        \nx\n \n=\n \nsort!\n(\ncollect\n(\nkeys\n(\ncm\n)))\n\n        \ny\n \n=\n \n[\ncm\n[\nxi\n]\n \nfor\n \nxi\n=\nx\n]\n\n        \nx\n,\n \ny\n\n    \nend\n\n\nend\n\n\n\n\n\n\nThe recipe defined above is a \"user recipe\", which builds a histogram for arrays of Float64, and otherwise shows a \"countmap\" of sorted unique values and their observed counts.  You only care about Float64 and String, and so you're results are fine:\n\n\nmycount\n(\nrand\n(\n500\n))\n\n\n\n\n\n\n\n\nmycount\n(\nrand\n([\n\"A\"\n,\n\"B\"\n,\n\"C\"\n],\n100\n))\n\n\n\n\n\n\n\n\nBut you didn't consider the person that, in the future, might want to pass integers to this recipe:\n\n\nmycount\n(\nrand\n(\n1\n:\n500\n,\n \n500\n))\n\n\n\n\n\n\n\n\nThis user expected integers to be treated as numbers and output a histogram, but instead they were treated like strings.  A simple solution would have been to replace \nif T.parameters[1] == Float64\n with \nif T.parameters[1] <: Number\n.  However, should we even depend on \nT\n having it's first parameter be the element type? (No)  So even better would be \nif eltype(arr) <: Number\n, which now allows any container with any numeric type to trigger the \"histogram\" logic.\n\n\nThis simple example outlines a common theme when developing Plots (or really any other Julia package).  Try to create the most generic implementation you can think of while maintaining correctness.  You don't know what crazy types someone else will use to try to access your functionality.\n\n\n\n\nCode Organization\n\n\nGenerally speaking, similar functionality is kept within the same file.  Within the \nsrc\n directory, much of the files should be self explanatory (for example, you'll find animation methods/macros in the \nanimation.jl\n file), but some could use a summary of contents:\n\n\n\n\nPlots.jl\n: imports, exports, shorthands, and initialization\n\n\nargs.jl\n: defaults, aliases, and attribute processing\n\n\ncomponents.jl\n: shapes, fonts, and other assorted goodies\n\n\npipeline.jl\n: code which builds the plots and subplots through recursive application of recipes\n\n\nrecipes.jl\n: primarily core series recipes\n\n\nseries.jl\n: core input data handling and processing\n\n\nutils.jl\n: lots of functionality that didn't have a home... \ngetindex\n/\nsetindex!\n for \nPlot\n/\nSubplot\n/\nAxis\n/\nSeries\n, \npush!\n/\nappend!\n for adding data to a series, \ncycle\n/\nunzip\n and similar utility functions, \nSegments\n/\nSegmentsIterator\n, etc.\n\n\n\n\nThese files should probably be reorganized, but until then...\n\n\nCreating new backends\n\n\nModel new backends on \nPlotsGR\n.  Implement the callbacks that are appropriate, especially \n_display\n and \n_show\n for GUI and image output respectively.\n\n\nStyle/Design Guidelines\n\n\n\n\nMake every effort to minimize external dependencies and exports.  Requiring new dependencies is the most likely way to make your PR \"unmergeable\".\n\n\nBe careful adding method signatures on existing methods with Base types (Array, etc) as you may override key functionality.  This is especially true with recipes.  Consider wrapping inputs in a new type (like in \"user recipes\").\n\n\nTerse code is ok, as is verbose code.  What's important is understanding and context.  Will someone reading your code know what you mean?  If not, consider writing comments to describe your reason for the design, or describe the hack you just implemented in clear prose.  Sometimes \nit's ok that your comments are longer than your code\n.\n\n\nPick your project for yourself, but write code for others.  It should be generic and useful beyond your needs, and you should \nnever break functionality\n because you can't figure out how to implement something well.  Spend more time on it... there's always a better way.\n\n\n\n\n\n\nGit-fu (or... the mechanics of contributing)\n\n\nMany people have trouble with Git.  More have trouble with Github.  I think much of the confusion happens when you run commands without understanding what they do.  We're all guilty of it, but recovering usually means \"starting over\".  In this section, I'll try to keep a simple, practical approach to making PRs.  It's worked well for me, though YMMV.\n\n\nGuidelines\n\n\nHere are some guidelines for the development workflow (Note: Even if you've made 20 PRs to Plots in the past, please read this as it may be different than past guidelines):\n\n\n\n\nCommit to a branch that belongs to you.\n  Typically that means you should give your branches names that are unique to you, and that might include information on the feature you're developing.  For example, I might choose to \ngit checkout -b tb-fonts\n when starting work on fonts.\n\n\nOpen a PR against master.\n  \nmaster\n is the \"bleeding edge\".  (Note: I used to recommend PRing to \ndev\n)\n\n\nOnly merge others changes when absolutely necessary.\n You should prefer to use \ngit rebase origin/master\n instead of \ngit merge origin/master\n.  A rebase replays your recent commits on top of the most recent \nmaster\n, avoiding complicated and messy merge commits and generally avoiding confusion.  If you follow the first rule, then you likely won't get yourself in trouble.  Rebase horror stories generally result when many people are working on the same branch.  I find \nthis resource\n is great for understanding the important parts of \ngit rebase\n.\n\n\n\n\n\n\nDevelopment Workflow\n\n\nMy suggestions for a smooth development workflow:\n\n\nFork the repo\n\n\nNavigate to the repo site (https://github.com/JuliaPlots/Plots.jl) and click the \"Fork\" button.  You might get a choice of which account or organization to place the fork.  I'll assume going forward that you forked to Github username \nuser123\n.\n\n\nSet up the git remote\n\n\nNavigate to the local repo.  Note: I'm assuming that you do development in your Julia directory, and using Mac/Linux.  Adjust as needed.\n\n\ncd ~/.julia/v0.5/Plots\ngit remote add forked git@github.com:user123/Plots.jl.git\n\n\n\n\n\nAfter running these commands, \ngit remote -v\n should show two remotes: \norigin\n (the main repo) and \nforked\n (your fork).  A remote is simply a reference/pointer to the github site hosting the repo, and a fork is simply any other git repo with a special link to the originating repo.\n\n\nCreate a new branch\n\n\nIf you're just starting work on a new feature:\n\n\ngit fetch origin\ngit checkout master\ngit merge --ff-only origin/master\ngit checkout -b user123-myfeature\ngit push -u forked user123-myfeature\n\n\n\n\n\nThe first three lines are meant to ensure you start from the main repo's master branch.  The \n--ff-only\n flag ensures you will only \"fast forward\" to newer commits, and avoids creating a new merge commit when you didn't mean to.  The \ngit checkout\n line both creates a new branch (the \n-b\n) pointing to the current commit and makes that branch current.  The \ngit push\n line adds this branch to your Github fork, and sets up the local branch to \"track\" (\n-u\n) the remote branch for subsequent \ngit push\n and \ngit pull\n calls.\n\n\nor... Reuse an old branch\n\n\nIf you have an ongoing development branch (say, \nuser123-dev\n) which you'd prefer to use (and which has previously been merged into master!) then you can get that up to date with:\n\n\ngit fetch origin\ngit checkout user123-dev\ngit merge --ff-only origin/master\ngit push forked user123-dev\n\n\n\n\n\nWe update our local copy of origin, checkout the dev branch, then attempt to \"fast-forward\" to the current master.  If successful, we push the branch back to our forked repo.\n\n\nWrite code and commit\n\n\nAfter powering up your favorite editor (maybe \nJuno\n?) and making some code changes to the repo, you'll want to \"commit\" or save a snapshot of all the changes you made.  After committing, you can \"push\" those changes to your forked repo on Github:\n\n\ngit add src/my_new_file.jl\ngit commit -am \"my commit message\"\ngit push forked user123-dev\n\n\n\n\n\nThe first line is optional, and is used when adding new files to the repo.  The \n-a\n means \"commit all my changes\", and the \n-m\n lets you write a note about the commit (you should always do this, and hopefully make it descriptive).\n\n\nSubmit a PR\n\n\nYou're almost there!  Browse to your fork (https://github.com/user123/Plots.jl).  Most likely there will be a section just above the code that asks if you'd like to create a PR from the \nuser123-dev\n branch.  If not, you can click the \"New pull request\" button.\n\n\nMake sure the \"base\" branch is JuliaPlots \nmaster\n and the \"compare\" branch is \nuser123-dev\n.  Add an informative title and description, and link to relevant issues or discussions, then click \"Create pull request\".  You may get some questions about it, and possibly suggestions of how to fix it to be \"merge-ready\".  Then hopefully it gets merged... thanks for the contribution!!\n\n\nCleanup\n\n\nAfter all of this, you will likely want to go back to using \nmaster\n (or possibly using a tagged release, once your feature is tagged).  To clean up:\n\n\ngit fetch origin\ngit checkout master\ngit merge --ff-only origin/master\ngit branch -d user123-dev\n\n\n\n\n\nThis catches your local master branch up to the remote master branch, then deletes the dev branch.  If you want to return to tagged releases, run \nPkg.free(\"Plots\")\n from the Julia REPL.\n\n\n\n\nTags\n\n\nNew tags should represent \"stable releases\"... those that you are happy to distribute to end-users.  Effort should be made to ensure tests pass before creating a new tag, and ideally new tests would be added which test your new functionality.  This is, of course, a much trickier problem for visualization libraries as compared to other software.  See the \ntesting section\n below.\n\n\nOnly JuliaPlots members may create a new tag.  To create a new tag, we'll create a new release on Github and use \nattobot\n to generate the PR to METADATA.  Create a new release at https://github.com/JuliaPlots/Plots.jl/releases/new (of course replacing the repo name with the package you're tagging).\n\n\nThe version number (vMAJOR.MINOR.PATCH) should be incremented using \nsemver\n, which generally means that breaking changes should increment the major number, backwards compatible changes should increment the minor number, and bug fixes should increment the patch number.  For \"v0.x.y\" versions, this requirement is relaxed.  The minor version can be incremented for breaking changes.\n\n\n\n\nTesting\n\n\nVisualRegressionTests\n\n\nTesting in Plots is done with the help of \nVisualRegressionTests\n.  Reference images are stored in \nPlotReferenceImages\n. Sometimes the reference images need to be updated (if features change, or if the underlying backend changes).  VisualRegressionTests makes it somewhat painless to update the reference images:\n\n\nFrom the Julia REPL, run \ninclude(Pkg.dir(\"Plots\",\"test\",\"runtests.jl\"))\n.  This will try to plot the tests, and then compare the results to the stored reference images.  If the test output is sufficiently different than the reference output (using Tim Holy's excellent algorithm for the comparison), then a GTK window will pop up with a side-by-side comparison.  You can choose to replace the reference image, or not, depending on whether a real error was discovered.\n\n\nAfter the reference images have been updated, navigate to PlotReferenceImages and push the changes to Github:\n\n\ncd ~/.julia/v0.5/PlotReferenceImages\ngit add Plots/*\ngit commit -am \"a useful message\"\ngit push\n\n\n\n\n\nIf there are mis-matches due to bugs, \ndon't update the reference image\n.\n\n\nTravis\n\n\nOn a \ngit push\n, Travis tests will be triggered.  This runs the same tests as above, downloading and comparing to the reference images, though with a larger tolerance for differences.  When Travis errors, it may be due to timeouts, stale reference images, or a host of other reasons.  Check the \nTravis logs\n to determine the reason.  If the tests are broken because of a new commit, consider rolling back.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#the-juliaplots-organization",
            "text": "JuliaPlots  is the home for all things Plots.  It was founded by  Tom Breloff , and extended through many contributions from  members  and others.  The first step in contributing will be to understand which package(s) are appropriate destinations for your code.",
            "title": "The JuliaPlots Organization"
        },
        {
            "location": "/contributing/#plots",
            "text": "This is the core package for:   Definitions of  plot / plot!  The  core processing pipeline  Base  recipes  for  path ,  scatter ,  bar , and many others  Generic  output  methods  Generic  layout  methods  Generic  animation  methods  Generic types: Plot, Subplot, Axis, Series, ...  Conveniences:  getindex / setindex ,  push! / append! ,  unzip ,  cycle , ...   This package depends on RecipesBase, PlotUtils, and PlotThemes.  When contributing new functionality/features, you should make best efforts to find a more appropriate home (StatPlots, PlotUtils, etc) than contributing to core Plots.  In general, the push has been to reduce the size and scope of Plots, when possible, and move features to other packages.",
            "title": "Plots"
        },
        {
            "location": "/contributing/#backends",
            "text": "In Julia versions v0.5 and earlier, backend code (such as code linking Plots with GR) lived in the  Plots/src/backends  directory.  As such, backend code should be contributed to core Plots.  Starting with v0.6, the backend code will live in separate repos, and loaded on demand.  For example, the GR backend is being developed at  PlotsGR .  Users targeting v0.6 and later should contribute to the respective backend package \"Plots[backend].jl\".  Note: As of 2/22/17, the  reorg  branch of Plots is needed for compatibility with the new backend repos.  This will be merged into the master branch sometime after the release of v0.6.  This redesign will help with improved support for precompilation, and a cleaner separation of \"generic plotting\" development and \"backend-specific\" development.",
            "title": "Backends"
        },
        {
            "location": "/contributing/#plotdocs",
            "text": "PlotDocs is the home of this documentation.  The documentation is built using the \"material\" theme in \"mkdocs\".  For those contributing documentation (to the  docs  directory of PlotDocs), it must be subsequently built and deployed using the following instructions:  # Note: the site is built inside the PlotDocs.jl repo, but then deployed to the JuliaPlots organization page\n\n# To build, run from inside the PlotDocs directory:\n#     mkdocs build --clean\n# (optional) Make the githubio remote point to JuliaPlots/juliaplots.github.io:\n#     git remote add githubio git@github.com:JuliaPlots/juliaplots.github.io.git\n# Add files, commit, then push:\n#     git push origin master\n# Push just the site directory to the master branch of githubio\n#     git subtree push --prefix site githubio master",
            "title": "PlotDocs"
        },
        {
            "location": "/contributing/#recipesbase",
            "text": "Seldom updated, but essential.  This is the package that you would depend on to create third-party recipes.  It contains the bare minimum to define new recipes.",
            "title": "RecipesBase"
        },
        {
            "location": "/contributing/#plotutils",
            "text": "Components that could be used for other (non-Plots) packages.  Anything that is sufficiently generic and useful could be contributed here.   Color (conversions, construction, conveniences)  Color gradients/maps  Tick computation",
            "title": "PlotUtils"
        },
        {
            "location": "/contributing/#plotthemes",
            "text": "Visual themes (i.e. attribute defaults) such as \"dark\", \"orange\", etc.",
            "title": "PlotThemes"
        },
        {
            "location": "/contributing/#statplots",
            "text": "An extension of Plots: Statistical plotting and tabular data.  Complex histograms and densities, correlation plots, and support for DataFrames.  Anything related to stats or special handling for table-like data should live here.",
            "title": "StatPlots"
        },
        {
            "location": "/contributing/#plotrecipes",
            "text": "An extension of StatPlots: Graphs, maps, and more.  If it's not a \"base recipe\", and also not clearly \"statistical\" in nature, then this package might be a good home.",
            "title": "PlotRecipes"
        },
        {
            "location": "/contributing/#mlplots",
            "text": "An extension of PlotRecipes, geared toward Machine Learning applications: neural nets, spike trains, ROC curves, and more.",
            "title": "MLPlots"
        },
        {
            "location": "/contributing/#ggplots",
            "text": "A prototype API/interface for \"Grammar of Graphics\" style plotting.  This likely wouldn't add actual functionality, but would give users coming from R/ggplot2 a simple way to avoid Gadfly.  I (Tom) wrote the prototype to show how easy it is, but since I dislike GoG-style, I never finished it.  Completing this package would be a great self-contained project for interested parties.",
            "title": "GGPlots"
        },
        {
            "location": "/contributing/#choosing-a-project",
            "text": "For people new to Plots, the first step should be to read (and reread) the documentation.  Code up some examples, play with the attributes, and try out multiple backends.  It's really hard to contribute to a project that you don't know how to use.",
            "title": "Choosing a Project"
        },
        {
            "location": "/contributing/#beginner-project-ideas",
            "text": "Create a new recipe : Preferably something you care about.  Maybe you want custom overlays of heatmaps and scatters?  Maybe you have an input format that isn't currently supported?  Make a recipe for it so you can just  plot(thing) .  Fix bugs : There are many \"bugs\" which are specific to one backend, or incorrectly implement features that are infrequently used.  Some ideas can be found in the  issues marked easy .  Add recipes to external packages : By depending on RecipesBase, a package can define a recipe for their custom types.  Submit a PR to a package you care about that adds a recipe for that package.  For example, see  this PR to add OHLC plots for TimeSeries.jl .",
            "title": "Beginner Project Ideas"
        },
        {
            "location": "/contributing/#intermediate-project-ideas",
            "text": "Improve your favorite backend : There are many missing features and other improvements that can be made to individual backends.  Most issues specific to a backend have a  special tag .  Help with documentation : This could come in the form of improved descriptions, additional examples, or full tutorials.  Please contribute improvements to  PlotDocs .  Help with the v0.6 reorganization : The  reorg  requires the annoying effort of creating new repos (PlotsPyPlot, PlotsPlotlyJS, etc) that hold the backend code.  I consider this intermediate because you need to know a little about Plots and git, but it's fairly straightforward to follow the model of PlotsGR.  Expand StatPlots functionality :  qqplot, DataStreams, or anything else you can think of.",
            "title": "Intermediate Project Ideas"
        },
        {
            "location": "/contributing/#advanced-project-ideas",
            "text": "ColorBar redesign : Colorbars  need serious love ... this would likely require a new Colorbar type that links with the appropriate Series object(s) and is independent during subplot layout.  We want to allow many series (possibly from multiple subplots) to use the same clims and to share a colorbar, or have multiple colorbars that can be flexibly positioned.  PlotSpec redesign : This  long standing redesign proposal  could allow generic serialization/deserialization of Plot data and attributes, as well as some improvements/optimizations when mutating plots.  For example, we could lazily compute attribute values, and intelligently flag them as \"dirty\" when they change, allowing backends to skip much of the wasted processing and unnecessary rebuilding that currently occurs.  Improve graph recipes : Lots to do here: clean up visuals, improve edge drawing, implement  layout algorithms , and much more.",
            "title": "Advanced Project Ideas"
        },
        {
            "location": "/contributing/#key-design-principles",
            "text": "Flexible and generic... these are the core principles underlying Plots development, and also tend to cause confusion when users laser-focus on their specific use case.  I (Tom) have painstakingly designed the core logic to support nearly any use case that exists or may exist.  I don't pretend to know how you want to use Plots, or what type of data you might pass in, or what sort of recipe you may want to apply.  As such, I try to avoid unnecessary restriction of types, or forced conversions, or many other pitfalls of limited visualization frameworks.  The result is a highly modular framework which is limited by your imagination.  When contributing new features to Plots (or the surrounding ecosystem), you should strive for this mentality as well.  New features should be left as generic as possible, while avoiding obvious feature clash.  As an example, you may want a new recipe that shows a histogram when passed Float64 numbers, but shows counts of every unique value for strings.  So you make a recipe that works perfectly for your purpose:  using   Plots ,   StatsBase  gr ( size = ( 300 , 300 ),   leg = false )  @userplot   MyCount  @recipe   function   f ( mc :: MyCount ) \n     # get the array from the args field \n     arr   =   mc . args [ 1 ] \n\n     T   =   typeof ( arr ) \n     if   T . parameters [ 1 ]   ==   Float64 \n         seriestype   :=   : histogram \n         arr \n     else \n         seriestype   :=   : bar \n         cm   =   countmap ( arr ) \n         x   =   sort! ( collect ( keys ( cm ))) \n         y   =   [ cm [ xi ]   for   xi = x ] \n         x ,   y \n     end  end   The recipe defined above is a \"user recipe\", which builds a histogram for arrays of Float64, and otherwise shows a \"countmap\" of sorted unique values and their observed counts.  You only care about Float64 and String, and so you're results are fine:  mycount ( rand ( 500 ))    mycount ( rand ([ \"A\" , \"B\" , \"C\" ], 100 ))    But you didn't consider the person that, in the future, might want to pass integers to this recipe:  mycount ( rand ( 1 : 500 ,   500 ))    This user expected integers to be treated as numbers and output a histogram, but instead they were treated like strings.  A simple solution would have been to replace  if T.parameters[1] == Float64  with  if T.parameters[1] <: Number .  However, should we even depend on  T  having it's first parameter be the element type? (No)  So even better would be  if eltype(arr) <: Number , which now allows any container with any numeric type to trigger the \"histogram\" logic.  This simple example outlines a common theme when developing Plots (or really any other Julia package).  Try to create the most generic implementation you can think of while maintaining correctness.  You don't know what crazy types someone else will use to try to access your functionality.",
            "title": "Key Design Principles"
        },
        {
            "location": "/contributing/#code-organization",
            "text": "Generally speaking, similar functionality is kept within the same file.  Within the  src  directory, much of the files should be self explanatory (for example, you'll find animation methods/macros in the  animation.jl  file), but some could use a summary of contents:   Plots.jl : imports, exports, shorthands, and initialization  args.jl : defaults, aliases, and attribute processing  components.jl : shapes, fonts, and other assorted goodies  pipeline.jl : code which builds the plots and subplots through recursive application of recipes  recipes.jl : primarily core series recipes  series.jl : core input data handling and processing  utils.jl : lots of functionality that didn't have a home...  getindex / setindex!  for  Plot / Subplot / Axis / Series ,  push! / append!  for adding data to a series,  cycle / unzip  and similar utility functions,  Segments / SegmentsIterator , etc.   These files should probably be reorganized, but until then...",
            "title": "Code Organization"
        },
        {
            "location": "/contributing/#creating-new-backends",
            "text": "Model new backends on  PlotsGR .  Implement the callbacks that are appropriate, especially  _display  and  _show  for GUI and image output respectively.",
            "title": "Creating new backends"
        },
        {
            "location": "/contributing/#styledesign-guidelines",
            "text": "Make every effort to minimize external dependencies and exports.  Requiring new dependencies is the most likely way to make your PR \"unmergeable\".  Be careful adding method signatures on existing methods with Base types (Array, etc) as you may override key functionality.  This is especially true with recipes.  Consider wrapping inputs in a new type (like in \"user recipes\").  Terse code is ok, as is verbose code.  What's important is understanding and context.  Will someone reading your code know what you mean?  If not, consider writing comments to describe your reason for the design, or describe the hack you just implemented in clear prose.  Sometimes  it's ok that your comments are longer than your code .  Pick your project for yourself, but write code for others.  It should be generic and useful beyond your needs, and you should  never break functionality  because you can't figure out how to implement something well.  Spend more time on it... there's always a better way.",
            "title": "Style/Design Guidelines"
        },
        {
            "location": "/contributing/#git-fu-or-the-mechanics-of-contributing",
            "text": "Many people have trouble with Git.  More have trouble with Github.  I think much of the confusion happens when you run commands without understanding what they do.  We're all guilty of it, but recovering usually means \"starting over\".  In this section, I'll try to keep a simple, practical approach to making PRs.  It's worked well for me, though YMMV.",
            "title": "Git-fu (or... the mechanics of contributing)"
        },
        {
            "location": "/contributing/#guidelines",
            "text": "Here are some guidelines for the development workflow (Note: Even if you've made 20 PRs to Plots in the past, please read this as it may be different than past guidelines):   Commit to a branch that belongs to you.   Typically that means you should give your branches names that are unique to you, and that might include information on the feature you're developing.  For example, I might choose to  git checkout -b tb-fonts  when starting work on fonts.  Open a PR against master.    master  is the \"bleeding edge\".  (Note: I used to recommend PRing to  dev )  Only merge others changes when absolutely necessary.  You should prefer to use  git rebase origin/master  instead of  git merge origin/master .  A rebase replays your recent commits on top of the most recent  master , avoiding complicated and messy merge commits and generally avoiding confusion.  If you follow the first rule, then you likely won't get yourself in trouble.  Rebase horror stories generally result when many people are working on the same branch.  I find  this resource  is great for understanding the important parts of  git rebase .",
            "title": "Guidelines"
        },
        {
            "location": "/contributing/#development-workflow",
            "text": "My suggestions for a smooth development workflow:",
            "title": "Development Workflow"
        },
        {
            "location": "/contributing/#fork-the-repo",
            "text": "Navigate to the repo site (https://github.com/JuliaPlots/Plots.jl) and click the \"Fork\" button.  You might get a choice of which account or organization to place the fork.  I'll assume going forward that you forked to Github username  user123 .",
            "title": "Fork the repo"
        },
        {
            "location": "/contributing/#set-up-the-git-remote",
            "text": "Navigate to the local repo.  Note: I'm assuming that you do development in your Julia directory, and using Mac/Linux.  Adjust as needed.  cd ~/.julia/v0.5/Plots\ngit remote add forked git@github.com:user123/Plots.jl.git  After running these commands,  git remote -v  should show two remotes:  origin  (the main repo) and  forked  (your fork).  A remote is simply a reference/pointer to the github site hosting the repo, and a fork is simply any other git repo with a special link to the originating repo.",
            "title": "Set up the git remote"
        },
        {
            "location": "/contributing/#create-a-new-branch",
            "text": "If you're just starting work on a new feature:  git fetch origin\ngit checkout master\ngit merge --ff-only origin/master\ngit checkout -b user123-myfeature\ngit push -u forked user123-myfeature  The first three lines are meant to ensure you start from the main repo's master branch.  The  --ff-only  flag ensures you will only \"fast forward\" to newer commits, and avoids creating a new merge commit when you didn't mean to.  The  git checkout  line both creates a new branch (the  -b ) pointing to the current commit and makes that branch current.  The  git push  line adds this branch to your Github fork, and sets up the local branch to \"track\" ( -u ) the remote branch for subsequent  git push  and  git pull  calls.",
            "title": "Create a new branch"
        },
        {
            "location": "/contributing/#or-reuse-an-old-branch",
            "text": "If you have an ongoing development branch (say,  user123-dev ) which you'd prefer to use (and which has previously been merged into master!) then you can get that up to date with:  git fetch origin\ngit checkout user123-dev\ngit merge --ff-only origin/master\ngit push forked user123-dev  We update our local copy of origin, checkout the dev branch, then attempt to \"fast-forward\" to the current master.  If successful, we push the branch back to our forked repo.",
            "title": "or... Reuse an old branch"
        },
        {
            "location": "/contributing/#write-code-and-commit",
            "text": "After powering up your favorite editor (maybe  Juno ?) and making some code changes to the repo, you'll want to \"commit\" or save a snapshot of all the changes you made.  After committing, you can \"push\" those changes to your forked repo on Github:  git add src/my_new_file.jl\ngit commit -am \"my commit message\"\ngit push forked user123-dev  The first line is optional, and is used when adding new files to the repo.  The  -a  means \"commit all my changes\", and the  -m  lets you write a note about the commit (you should always do this, and hopefully make it descriptive).",
            "title": "Write code and commit"
        },
        {
            "location": "/contributing/#submit-a-pr",
            "text": "You're almost there!  Browse to your fork (https://github.com/user123/Plots.jl).  Most likely there will be a section just above the code that asks if you'd like to create a PR from the  user123-dev  branch.  If not, you can click the \"New pull request\" button.  Make sure the \"base\" branch is JuliaPlots  master  and the \"compare\" branch is  user123-dev .  Add an informative title and description, and link to relevant issues or discussions, then click \"Create pull request\".  You may get some questions about it, and possibly suggestions of how to fix it to be \"merge-ready\".  Then hopefully it gets merged... thanks for the contribution!!",
            "title": "Submit a PR"
        },
        {
            "location": "/contributing/#cleanup",
            "text": "After all of this, you will likely want to go back to using  master  (or possibly using a tagged release, once your feature is tagged).  To clean up:  git fetch origin\ngit checkout master\ngit merge --ff-only origin/master\ngit branch -d user123-dev  This catches your local master branch up to the remote master branch, then deletes the dev branch.  If you want to return to tagged releases, run  Pkg.free(\"Plots\")  from the Julia REPL.",
            "title": "Cleanup"
        },
        {
            "location": "/contributing/#tags",
            "text": "New tags should represent \"stable releases\"... those that you are happy to distribute to end-users.  Effort should be made to ensure tests pass before creating a new tag, and ideally new tests would be added which test your new functionality.  This is, of course, a much trickier problem for visualization libraries as compared to other software.  See the  testing section  below.  Only JuliaPlots members may create a new tag.  To create a new tag, we'll create a new release on Github and use  attobot  to generate the PR to METADATA.  Create a new release at https://github.com/JuliaPlots/Plots.jl/releases/new (of course replacing the repo name with the package you're tagging).  The version number (vMAJOR.MINOR.PATCH) should be incremented using  semver , which generally means that breaking changes should increment the major number, backwards compatible changes should increment the minor number, and bug fixes should increment the patch number.  For \"v0.x.y\" versions, this requirement is relaxed.  The minor version can be incremented for breaking changes.",
            "title": "Tags"
        },
        {
            "location": "/contributing/#testing",
            "text": "",
            "title": "Testing"
        },
        {
            "location": "/contributing/#visualregressiontests",
            "text": "Testing in Plots is done with the help of  VisualRegressionTests .  Reference images are stored in  PlotReferenceImages . Sometimes the reference images need to be updated (if features change, or if the underlying backend changes).  VisualRegressionTests makes it somewhat painless to update the reference images:  From the Julia REPL, run  include(Pkg.dir(\"Plots\",\"test\",\"runtests.jl\")) .  This will try to plot the tests, and then compare the results to the stored reference images.  If the test output is sufficiently different than the reference output (using Tim Holy's excellent algorithm for the comparison), then a GTK window will pop up with a side-by-side comparison.  You can choose to replace the reference image, or not, depending on whether a real error was discovered.  After the reference images have been updated, navigate to PlotReferenceImages and push the changes to Github:  cd ~/.julia/v0.5/PlotReferenceImages\ngit add Plots/*\ngit commit -am \"a useful message\"\ngit push  If there are mis-matches due to bugs,  don't update the reference image .",
            "title": "VisualRegressionTests"
        },
        {
            "location": "/contributing/#travis",
            "text": "On a  git push , Travis tests will be triggered.  This runs the same tests as above, downloading and comparing to the reference images, though with a larger tolerance for differences.  When Travis errors, it may be due to timeouts, stale reference images, or a host of other reasons.  Check the  Travis logs  to determine the reason.  If the tests are broken because of a new commit, consider rolling back.",
            "title": "Travis"
        },
        {
            "location": "/pipeline/",
            "text": "Processing Pipeline\n\n\nPlotting commands will send inputs through a series of preprocessing steps, in order to convert, simplify, and generalize. The idea is that end-users need incredible flexibility in what (and how) they are able to make calls.  They may want total control over plot attributes, or none at all.  There may be 8 attributes that are constant, but one that varies by data series.  We need to be able to easily layer complex plots on top of each other, and easily define what they should look like.  Input data might come in any form.\n\n\nI'll go through the steps that occur after a call to \nplot()\n or \nplot!()\n, and hint at the power and flexibility that arises.\n\n\nAn example command\n\n\nSuppose we have data:\n\n\nn\n \n=\n \n100\n\n\nx\n,\n \ny\n \n=\n \nlinspace\n(\n0\n,\n1\n,\nn\n),\n \nrandn\n(\nn\n,\n \n3\n)\n\n\n\n\n\n\nand we'd like to visualize \nx\n against each column of \ny\n.  Here's a sample command in Plots:\n\n\nusing\n \nPlots\n;\n \npyplot\n()\n\n\nplot\n(\nx\n,\n \ny\n,\n \nline\n \n=\n \n(\n0.5\n,\n \n[\n4\n \n1\n \n0\n],\n \n[\n:\npath\n \n:\nscatter\n \n:\ndensity\n]),\n\n    \nmarker\n=\n(\n10\n,\n \n0.5\n,\n \n[\n:\nnone\n \n:+\n \n:\nnone\n]),\n \nfill\n=\n0.5\n,\n\n    \norientation\n \n=\n \n:\nh\n,\n \ntitle\n \n=\n \n\"My title\"\n)\n\n\n\n\n\n\n\n\nIn this example, we have an input matrix, and we'd like to plot three series on top of each other, one for each column of data.\nWe create a row vector (1x3 matrix) of symbols to assign different visualization types for each series, set the orientation of the histogram, and set\nalpha values.\n\n\nFor comparison's sake, this is somewhat similar to the following calls in PyPlot:\n\n\nimport\n \nPyPlot\n\n\nfig\n \n=\n \nPyPlot\n.\ngcf\n()\n\n\nfig\n[\n:\nset_size_inches\n](\n4\n,\n3\n,\nforward\n=\ntrue\n)\n\n\nfig\n[\n:\nset_dpi\n](\n100\n)\n\n\nPyPlot\n.\nclf\n()\n\n\n\nPyPlot\n.\nplot\n(\nx\n,\n \ny\n[\n:\n,\n1\n],\n \nalpha\n \n=\n \n0.5\n,\n \n\"steelblue\"\n,\n \nlinewidth\n \n=\n \n4\n)\n\n\nPyPlot\n.\nscatter\n(\nx\n,\n \ny\n[\n:\n,\n2\n],\n \nalpha\n \n=\n \n0.5\n,\n \nmarker\n \n=\n \n\"+\"\n,\n \ns\n \n=\n \n100\n,\n \nc\n=\n\"orangered\"\n)\n\n\nPyPlot\n.\nplt\n[\n:\nhist\n](\ny\n[\n:\n,\n3\n],\n \norientation\n \n=\n \n\"horizontal\"\n,\n \nalpha\n \n=\n \n0.5\n,\n\n                          \nnormed\n \n=\n \ntrue\n,\n \nbins\n=\n30\n,\n \ncolor\n=\n\"green\"\n,\n\n                          \nlinewidth\n \n=\n \n0\n)\n\n\n\nax\n \n=\n \nPyPlot\n.\ngca\n()\n\n\nax\n[\n:\nxaxis\n][\n:\ngrid\n](\ntrue\n)\n\n\nax\n[\n:\nyaxis\n][\n:\ngrid\n](\ntrue\n)\n\n\nPyPlot\n.\ntitle\n(\n\"My title\"\n)\n\n\nPyPlot\n.\nlegend\n([\n\"y1\"\n,\n\"y2\"\n])\n\n\nPyPlot\n.\nshow\n()\n\n\n\n\n\n\n\n\nStep 1: Preprocess Attributes\n\n\nSee \nreplacing aliases\n and \nmagic arguments\n for details.\n\n\nAfterwards, there are some arguments which are simplified and compressed, such as converting the boolean setting \ncolorbar = false\n to the internal description \ncolorbar = :none\n as to allow complex behavior without complex interface, replacing \nnothing\n with the invisible \nRGBA(0,0,0,0)\n, and similar.\n\n\n\n\nStep 2: Process input data: User Recipes, Grouping, and more\n\n\nPlots will rarely ask you to pre-process your own inputs.  You have a Julia array? Great.  DataFrame? No problem.  Surface function? You got it.\n\n\nDuring this step, Plots will translate your input data (within the context of the plot type and other inputs) into a list of sliced and/or expanded representations,\nwhere each item represents the data for one plot series.  Under the hood, it makes heavy use of \nmultiple dispatch\n and \nrecipes\n.\n\n\nInputs are recursively processed until a matching recipe is found.  This means you can make modular and hierarchical recipes which are processed just like anything built into Plots.\n\n\ntype\n \nMyVecWrapper\n\n  \nv\n::\nVector\n{\nFloat64\n}\n\n\nend\n\n\nmv\n \n=\n \nMyVecWrapper\n(\nrand\n(\n100\n))\n\n\n\n@recipe\n \nfunction\n \nf\n(\nmv\n::\nMyVecWrapper\n)\n\n    \nmarkershape\n \n-->\n \n:\ncircle\n\n    \nmarkersize\n  \n-->\n \n30\n\n    \nmv\n.\nv\n\n\nend\n\n\n\nplot\n(\n\n    \nplot\n(\nmv\n.\nv\n),\n\n    \nplot\n(\nmv\n)\n\n\n)\n\n\n\n\n\n\n\n\nNote that if dispatch does not find a recipe for the full combination of inputs, it will then try to apply \ntype recipes\n to each individual argument.\n\n\nThis hook gave us a nice way to swap out the input data and add custom visualization attributes for a user type.  Things like error bars, regression lines, ribbons, and group filtering are also handled during this recursive pass.\n\n\nGroups: When you'd like to split a data series into multiple plot series, you can use the \ngroup\n keyword.  Attributes can be applied to the resulting series as if your data had been already separated into distinct input data.  The \ngroup\n variable determines how to split the data and also assigns the legend label.\n\n\nIn this example, we split the data points into 3 groups randomly, and give them different marker shapes (\n[:s :o :x]\n are aliases for \n:star5\n, \n:octagon\n, and \n:xcross\n). The other attibutes (\n:markersize\n and \n:markeralpha\n) are shared.\n\n\nscatter\n(\nrand\n(\n100\n),\n \ngroup\n \n=\n \nrand\n(\n1\n:\n3\n,\n \n100\n),\n \nmarker\n \n=\n \n(\n10\n,\n0.3\n,[\n:\ns\n \n:\no\n \n:\nx\n]))\n\n\n\n\n\n\n\n\n\n\nStep 3:  Initialize and update Plot and Subplots\n\n\nAttributes which apply to Plot, Subplot, or Axis objects are pulled out and processed.  Backend methods for initializing the figure/window are triggered, and the \nlayout\n is built.\n\n\n\n\nStep 4: Series Recipes\n\n\nThis part is somewhat magical.  Following the first three steps, we have a list of keyword dictionaries (type \nKW\n) which contain both data and attributes.  Now we will recursively apply \nseries recipes\n, first checking to see if a backend supports a series type natively, and if not, applying a series recipe and re-processing.\n\n\nThe result is that one can create generic recipes (converting a histogram to a bar plot, for example), which will reduce the series to the highest-level type(s) that a backend supports.  Since recipes are so simple to create, we can do complex visualizations in backends which support very little natively.\n\n\n\n\nStep 5: Preparing for output\n\n\nMuch of the heavy processing is offloaded until it's needed.  Plots will try to avoid expensive graphical updates until you actually choose to \ndisplay\n the plot.  Just before display, we will compute the layout specifics and bounding boxes of the subplots and other plot components, then trigger the callback to the backend code to draw/update the plot.\n\n\n\n\nStep 6: Display it\n\n\nOpen/refresh a GUI window, write to a file, or display inline in IJulia.  Remember that, in IJulia or the REPL, \na Plot is only displayed when returned\n (a semicolon will suppress the return), or if explicitly displayed with \ndisplay()\n, \ngui()\n, or by adding \nshow = true\n to your plot command.\n\n\n\nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)",
            "title": "Internals"
        },
        {
            "location": "/pipeline/#processing-pipeline",
            "text": "Plotting commands will send inputs through a series of preprocessing steps, in order to convert, simplify, and generalize. The idea is that end-users need incredible flexibility in what (and how) they are able to make calls.  They may want total control over plot attributes, or none at all.  There may be 8 attributes that are constant, but one that varies by data series.  We need to be able to easily layer complex plots on top of each other, and easily define what they should look like.  Input data might come in any form.  I'll go through the steps that occur after a call to  plot()  or  plot!() , and hint at the power and flexibility that arises.",
            "title": "Processing Pipeline"
        },
        {
            "location": "/pipeline/#an-example-command",
            "text": "Suppose we have data:  n   =   100  x ,   y   =   linspace ( 0 , 1 , n ),   randn ( n ,   3 )   and we'd like to visualize  x  against each column of  y .  Here's a sample command in Plots:  using   Plots ;   pyplot ()  plot ( x ,   y ,   line   =   ( 0.5 ,   [ 4   1   0 ],   [ : path   : scatter   : density ]), \n     marker = ( 10 ,   0.5 ,   [ : none   :+   : none ]),   fill = 0.5 , \n     orientation   =   : h ,   title   =   \"My title\" )    In this example, we have an input matrix, and we'd like to plot three series on top of each other, one for each column of data.\nWe create a row vector (1x3 matrix) of symbols to assign different visualization types for each series, set the orientation of the histogram, and set\nalpha values.  For comparison's sake, this is somewhat similar to the following calls in PyPlot:  import   PyPlot  fig   =   PyPlot . gcf ()  fig [ : set_size_inches ]( 4 , 3 , forward = true )  fig [ : set_dpi ]( 100 )  PyPlot . clf ()  PyPlot . plot ( x ,   y [ : , 1 ],   alpha   =   0.5 ,   \"steelblue\" ,   linewidth   =   4 )  PyPlot . scatter ( x ,   y [ : , 2 ],   alpha   =   0.5 ,   marker   =   \"+\" ,   s   =   100 ,   c = \"orangered\" )  PyPlot . plt [ : hist ]( y [ : , 3 ],   orientation   =   \"horizontal\" ,   alpha   =   0.5 , \n                           normed   =   true ,   bins = 30 ,   color = \"green\" , \n                           linewidth   =   0 )  ax   =   PyPlot . gca ()  ax [ : xaxis ][ : grid ]( true )  ax [ : yaxis ][ : grid ]( true )  PyPlot . title ( \"My title\" )  PyPlot . legend ([ \"y1\" , \"y2\" ])  PyPlot . show ()",
            "title": "An example command"
        },
        {
            "location": "/pipeline/#step-1-preprocess-attributes",
            "text": "See  replacing aliases  and  magic arguments  for details.  Afterwards, there are some arguments which are simplified and compressed, such as converting the boolean setting  colorbar = false  to the internal description  colorbar = :none  as to allow complex behavior without complex interface, replacing  nothing  with the invisible  RGBA(0,0,0,0) , and similar.",
            "title": "Step 1: Preprocess Attributes"
        },
        {
            "location": "/pipeline/#step-2-process-input-data-user-recipes-grouping-and-more",
            "text": "Plots will rarely ask you to pre-process your own inputs.  You have a Julia array? Great.  DataFrame? No problem.  Surface function? You got it.  During this step, Plots will translate your input data (within the context of the plot type and other inputs) into a list of sliced and/or expanded representations,\nwhere each item represents the data for one plot series.  Under the hood, it makes heavy use of  multiple dispatch  and  recipes .  Inputs are recursively processed until a matching recipe is found.  This means you can make modular and hierarchical recipes which are processed just like anything built into Plots.  type   MyVecWrapper \n   v :: Vector { Float64 }  end  mv   =   MyVecWrapper ( rand ( 100 ))  @recipe   function   f ( mv :: MyVecWrapper ) \n     markershape   -->   : circle \n     markersize    -->   30 \n     mv . v  end  plot ( \n     plot ( mv . v ), \n     plot ( mv )  )    Note that if dispatch does not find a recipe for the full combination of inputs, it will then try to apply  type recipes  to each individual argument.  This hook gave us a nice way to swap out the input data and add custom visualization attributes for a user type.  Things like error bars, regression lines, ribbons, and group filtering are also handled during this recursive pass.  Groups: When you'd like to split a data series into multiple plot series, you can use the  group  keyword.  Attributes can be applied to the resulting series as if your data had been already separated into distinct input data.  The  group  variable determines how to split the data and also assigns the legend label.  In this example, we split the data points into 3 groups randomly, and give them different marker shapes ( [:s :o :x]  are aliases for  :star5 ,  :octagon , and  :xcross ). The other attibutes ( :markersize  and  :markeralpha ) are shared.  scatter ( rand ( 100 ),   group   =   rand ( 1 : 3 ,   100 ),   marker   =   ( 10 , 0.3 ,[ : s   : o   : x ]))",
            "title": "Step 2: Process input data: User Recipes, Grouping, and more"
        },
        {
            "location": "/pipeline/#step-3-initialize-and-update-plot-and-subplots",
            "text": "Attributes which apply to Plot, Subplot, or Axis objects are pulled out and processed.  Backend methods for initializing the figure/window are triggered, and the  layout  is built.",
            "title": "Step 3:  Initialize and update Plot and Subplots"
        },
        {
            "location": "/pipeline/#step-4-series-recipes",
            "text": "This part is somewhat magical.  Following the first three steps, we have a list of keyword dictionaries (type  KW ) which contain both data and attributes.  Now we will recursively apply  series recipes , first checking to see if a backend supports a series type natively, and if not, applying a series recipe and re-processing.  The result is that one can create generic recipes (converting a histogram to a bar plot, for example), which will reduce the series to the highest-level type(s) that a backend supports.  Since recipes are so simple to create, we can do complex visualizations in backends which support very little natively.",
            "title": "Step 4: Series Recipes"
        },
        {
            "location": "/pipeline/#step-5-preparing-for-output",
            "text": "Much of the heavy processing is offloaded until it's needed.  Plots will try to avoid expensive graphical updates until you actually choose to  display  the plot.  Just before display, we will compute the layout specifics and bounding boxes of the subplots and other plot components, then trigger the callback to the backend code to draw/update the plot.",
            "title": "Step 5: Preparing for output"
        },
        {
            "location": "/pipeline/#step-6-display-it",
            "text": "Open/refresh a GUI window, write to a file, or display inline in IJulia.  Remember that, in IJulia or the REPL,  a Plot is only displayed when returned  (a semicolon will suppress the return), or if explicitly displayed with  display() ,  gui() , or by adding  show = true  to your plot command.  \nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)",
            "title": "Step 6: Display it"
        },
        {
            "location": "/layouts/",
            "text": "Layouts\n\n\nAs of v0.7.0, Plots has taken control of subplot positioning, allowing complex, nested grids of subplots and components.  Care has been taken to keep the framework flexible and generic, so that backends need only support the ability to precisely define the absolute position of a subplot, and they get the full power of nesting, plot area alignment, and more.  Just set the \nlayout\n keyword in a call to \nplot(...)\n\n\nIt's helpful at this point to review terminology:\n\n\n\n\nPlot\n: The whole figure/window\n\n\nSubplot\n: One subplot, containing a title, axes, colorbar, legend, and plot area.\n\n\nAxis\n: One axis of a subplot, containing axis guide (label), tick labels, and tick marks.\n\n\nPlot Area\n: The part of a subplot where the data is shown... contains the series, grid lines, etc.\n\n\nSeries\n: One distinct visualization of data. (For example: a line or a set of markers)\n\n\n\n\n\n\nSimple Layouts\n\n\nPass an integer to \nlayout\n to allow it to automatically compute a grid size for that many subplots:\n\n\n# create a 2x2 grid, and map each of the 4 series to one of the subplots\n\n\nplot\n(\nrand\n(\n100\n,\n4\n),\n \nlayout\n \n=\n \n4\n)\n\n\n\n\n\n\n\n\nPass a tuple to \nlayout\n to create a grid of that size:\n\n\n# create a 4x1 grid, and map each of the 4 series to one of the subplots\n\n\nplot\n(\nrand\n(\n100\n,\n4\n),\n \nlayout\n \n=\n \n(\n4\n,\n1\n))\n\n\n\n\n\n\n\n\nMore complex grid layouts can be created with the \ngrid(...)\n constructor:\n\n\nplot\n(\nrand\n(\n100\n,\n4\n),\n \nlayout\n \n=\n \ngrid\n(\n4\n,\n1\n,\nheights\n=\n[\n0.1\n,\n0.4\n,\n0.4\n,\n0.1\n]))\n\n\n\n\n\n\n\n\n\n\nAdvanced Layouts\n\n\nThe \n@layout\n macro is the easiest way to define complex layouts, using Julia's \nmultidimensional Array construction\n as the basis for a custom layout syntax.  Precise sizing can be acheived with curly brackets, otherwise the free space is equally split between the \nplot areas\n of subplots.\n\n\nl\n \n=\n \n@layout\n \n[\n  \na\n{\n0.3\nw\n}\n \n[\ngrid\n(\n3\n,\n3\n)\n\n                         \nb\n{\n0.2\nh\n}\n \n]]\n\n\nplot\n(\n\n    \nrand\n(\n10\n,\n11\n),\n\n    \nlayout\n \n=\n \nl\n,\n \nlegend\n \n=\n \nfalse\n,\n \nseriestype\n \n=\n \n[\n:\nbar\n \n:\nscatter\n \n:\npath\n],\n\n    \ntitle\n \n=\n \n[\n\"(\n$i\n)\"\n \nfor\n \ni\n=\n1\n:\n11\n]\n'\n,\n \ntitleloc\n \n=\n \n:\nright\n,\n \ntitlefont\n \n=\n \nfont\n(\n8\n)\n\n\n)\n\n\n\n\n\n\n\n\n\n\nCreate inset (floating) subplots using the \ninset_subplots\n attribute. \ninset_subplots\n takes a list of (parent_layout, BoundingBox) tuples, where the bounding box is relative to the parent.\n\n\nUse \npx\n/\nmm\n/\ninch\n for absolute coords, \nw\n/\nh\n for percentage relative to the parent. Origin is top-left. \nh_anchor\n/\nv_anchor\n define what the \nx\n/\ny\n inputs of the bounding box refer to.\n\n\n# boxplot is defined in StatPlots\n\n\nusing\n \nStatPlots\n\n\ngr\n(\nleg\n=\nfalse\n,\n \nbg\n=:\nlightgrey\n)\n\n\n\n# Create a filled contour and boxplot side by side.\n\n\nplot\n(\ncontourf\n(\nrandn\n(\n10\n,\n20\n)),\n \nboxplot\n(\nrand\n(\n1\n:\n4\n,\n1000\n),\nrandn\n(\n1000\n)))\n\n\n\n# Add a histogram inset on the heatmap.\n\n\n# We set the (optional) position relative to bottom-right of the 1st subplot.\n\n\n# The call is `bbox(x, y, width, height, origin...)`, where numbers are treated as \"percent of parent\"\n\n\nhistogram!\n(\nrandn\n(\n1000\n),\n \ninset\n \n=\n \n(\n1\n,\n \nbbox\n(\n0.05\n,\n0.05\n,\n0.5\n,\n0.25\n,\n:\nbottom\n,\n:\nright\n)),\n \nticks\n=\nnothing\n,\n \nsubplot\n=\n3\n,\n \nbg_inside\n=\nnothing\n)\n\n\n\n# Add sticks floating in the window (inset relative to the window, as opposed to being relative to a subplot)\n\n\nsticks!\n(\nrandn\n(\n100\n),\n \ninset\n \n=\n \nbbox\n(\n0\n,\n-\n0.2\n,\n200\npx\n,\n100\npx\n,\n:\ncenter\n),\n \nticks\n=\nnothing\n,\n \nsubplot\n=\n4\n)",
            "title": "Layouts"
        },
        {
            "location": "/layouts/#layouts",
            "text": "As of v0.7.0, Plots has taken control of subplot positioning, allowing complex, nested grids of subplots and components.  Care has been taken to keep the framework flexible and generic, so that backends need only support the ability to precisely define the absolute position of a subplot, and they get the full power of nesting, plot area alignment, and more.  Just set the  layout  keyword in a call to  plot(...)  It's helpful at this point to review terminology:   Plot : The whole figure/window  Subplot : One subplot, containing a title, axes, colorbar, legend, and plot area.  Axis : One axis of a subplot, containing axis guide (label), tick labels, and tick marks.  Plot Area : The part of a subplot where the data is shown... contains the series, grid lines, etc.  Series : One distinct visualization of data. (For example: a line or a set of markers)",
            "title": "Layouts"
        },
        {
            "location": "/layouts/#simple-layouts",
            "text": "Pass an integer to  layout  to allow it to automatically compute a grid size for that many subplots:  # create a 2x2 grid, and map each of the 4 series to one of the subplots  plot ( rand ( 100 , 4 ),   layout   =   4 )    Pass a tuple to  layout  to create a grid of that size:  # create a 4x1 grid, and map each of the 4 series to one of the subplots  plot ( rand ( 100 , 4 ),   layout   =   ( 4 , 1 ))    More complex grid layouts can be created with the  grid(...)  constructor:  plot ( rand ( 100 , 4 ),   layout   =   grid ( 4 , 1 , heights = [ 0.1 , 0.4 , 0.4 , 0.1 ]))",
            "title": "Simple Layouts"
        },
        {
            "location": "/layouts/#advanced-layouts",
            "text": "The  @layout  macro is the easiest way to define complex layouts, using Julia's  multidimensional Array construction  as the basis for a custom layout syntax.  Precise sizing can be acheived with curly brackets, otherwise the free space is equally split between the  plot areas  of subplots.  l   =   @layout   [    a { 0.3 w }   [ grid ( 3 , 3 ) \n                          b { 0.2 h }   ]]  plot ( \n     rand ( 10 , 11 ), \n     layout   =   l ,   legend   =   false ,   seriestype   =   [ : bar   : scatter   : path ], \n     title   =   [ \"( $i )\"   for   i = 1 : 11 ] ' ,   titleloc   =   : right ,   titlefont   =   font ( 8 )  )     Create inset (floating) subplots using the  inset_subplots  attribute.  inset_subplots  takes a list of (parent_layout, BoundingBox) tuples, where the bounding box is relative to the parent.  Use  px / mm / inch  for absolute coords,  w / h  for percentage relative to the parent. Origin is top-left.  h_anchor / v_anchor  define what the  x / y  inputs of the bounding box refer to.  # boxplot is defined in StatPlots  using   StatPlots  gr ( leg = false ,   bg =: lightgrey )  # Create a filled contour and boxplot side by side.  plot ( contourf ( randn ( 10 , 20 )),   boxplot ( rand ( 1 : 4 , 1000 ), randn ( 1000 )))  # Add a histogram inset on the heatmap.  # We set the (optional) position relative to bottom-right of the 1st subplot.  # The call is `bbox(x, y, width, height, origin...)`, where numbers are treated as \"percent of parent\"  histogram! ( randn ( 1000 ),   inset   =   ( 1 ,   bbox ( 0.05 , 0.05 , 0.5 , 0.25 , : bottom , : right )),   ticks = nothing ,   subplot = 3 ,   bg_inside = nothing )  # Add sticks floating in the window (inset relative to the window, as opposed to being relative to a subplot)  sticks! ( randn ( 100 ),   inset   =   bbox ( 0 , - 0.2 , 200 px , 100 px , : center ),   ticks = nothing ,   subplot = 4 )",
            "title": "Advanced Layouts"
        },
        {
            "location": "/recipes/",
            "text": "Advanced Recipes\n\n\nLike other tools in Plots, recipes are relatively simple, but extremely powerful.  A recipe is created by invoking the \n@recipe\n macro, which is defined in the lightweight package \nRecipesBase\n.  There are many examples of recipes both within Plots and in many external packages, including \nPlotRecipes\n.\n\n\nThere are four main types of recipes in Plots (listed in the order they are processed):\n\n\n\n\nUser Recipes\n\n\nType Recipes\n\n\nPlot Recipes\n\n\nSeries Recipes\n\n\n\n\nThe recipe type is determined completely by the dispatch signature.\n  Each recipe type is called from a different part of the \nplotting pipeline\n, so you will choose a type of recipe to match how much processing you want completed before your recipe is applied.\n\n\nThese are the dispatch signatures for each type (note that most of these can accept positional or keyword args, denoted by \n...\n):\n\n\n\n\nUser Recipes: \n@recipe function f(custom_arg_1::T, custom_arg_2::S, ...; ...) end\n\n\nProcess a unique set of types early in the pipeline.  Good for user-defined types or special combinations of Base types.\n\n\nThe \n@userplot\n macro is a nice convenience which both defines a new type (to ensure correct dispatch) and exports shorthands.\n\n\nSee \ngraphplot\n for an example.\n\n\n\n\n\n\nType Recipes: \n@recipe function f{T<:MyType}(::Type{T}, val::T) end\n\n\nFor user-defined types which wrap or have a one-to-one mapping to something supported by Plots, simply define a conversion method.\n\n\nNote: this is effectively saying \"when you see type T, replace it with ...\"\n\n\nSee \nSymPy\n for an example.\n\n\n\n\n\n\nPlot Recipes: \n@recipe function f(::Type{Val{:myplotrecipename}}, plt::Plot; ...) end\n\n\nThese are called after input data has been processed, but \nbefore the plot is created\n.\n\n\nBuild layouts, add subplots, and other plot-wide attributes\n\n\nSee \nmarginalhist\n for an example.\n\n\n\n\n\n\nSeries Recipes: \n@recipe function f(::Type{Val{:myseriesrecipename}}, x, y, z; ...) end\n\n\nThese are the last calls to happen.  Each backend will support a short list of series types (\npath\n, \nshape\n, \nhistogram\n, etc).  If a series type is natively supported, processing is passed (delegated) to the backend.  If a series type is \nnot\n natively supported by the backend, we attempt to call a \"series recipe\".\n\n\nNote: If there's no series recipe defined, and the backend doesn't support it, you'll see an error like: \nERROR: The backend must not support the series type Val{:hi}, and there isn't a series recipe defined.\n\n\nNote: You must have the \nx, y, z\n included in the signature, or it won't be processed as a series type!!\n\n\n\n\n\n\n\n\nRecipe Syntax/Rules\n\n\nLets decompose what's happening inside the recipe macro, starting with a simple recipe:\n\n\ntype\n \nMyType\n \nend\n\n\n\n@recipe\n \nfunction\n \nf\n(\n::\nMyType\n,\n \nn\n::\nInteger\n \n=\n \n10\n;\n \nadd_marker\n \n=\n \nfalse\n)\n\n    \nlinecolor\n   \n-->\n \n:\nblue\n\n    \nseriestype\n  \n:=\n  \n:\npath\n\n    \nmarkershape\n \n-->\n \n(\nadd_marker\n \n?\n \n:\ncircle\n \n:\n \n:\nnone\n)\n\n    \ndelete!\n(\nplotattributes\n,\n \n:\nadd_marker\n)\n\n    \nrand\n(\nn\n)\n\n\nend\n\n\n\n\n\n\nWe create a new type \nMyType\n, which is empty, and used purely for dispatch.  Our goal here is to create a random path of \nn\n points.\n\n\nThere are a few important things to know, after which recipes boil down to updating an attribute dictionary and returning input data:\n\n\n\n\nA recipe signature \nf(args...; kw...)\n is converted into a definition of \napply_recipe(plotattributes::KW, args...)\n where:\n\n\nplotattributes\n is an attribute dictionary of type \ntypealias KW Dict{Symbol,Any}\n\n\nYour \nargs\n must be distinct enough that dispatch will call your definition (and without masking an existing definition).  Using a custom data type will ensure proper dispatch.\n\n\nThe function \nf\n is unused/meaningless... call it whatever you want.\n\n\n\n\n\n\nThe special operator \n-->\n turns \nlinecolor --> :blue\n into \nget!(plotattributes, :linecolor, :blue)\n, setting the attribute only when it doesn't already exist.  (Tip: Wrap the right hand side in parentheses for complex expressions.)\n\n\nThe special operator \n:=\n turns \nseriestype := :path\n into \nplotattributes[:seriestype] = :path\n, forcing that attribute value.  (Tip: Wrap the right hand side in parentheses for complex expressions.)\n\n\nThe return value of the recipe is the \nargs\n of a \nRecipeData\n object, which also has a reference to the attribute dictionary.\n\n\nA recipe returns a Vector{RecipeData}.  We'll see how to add to this list later with the \n@series\n macro.\n\n\n\n\nBreaking down the example:\n\n\nIn the example above, we use \nMyType\n for dispatch, with optional positional argument \nn::Integer\n:\n\n\n@recipe\n \nfunction\n \nf\n(\n::\nMyType\n,\n \nn\n::\nInteger\n \n=\n \n10\n;\n \nadd_marker\n \n=\n \nfalse\n)\n\n\n\n\n\n\nWith a call to \nplot(MyType())\n or similar, this recipe will be invoked.  If \nlinecolor\n has not been set, it is set to \n:blue\n:\n\n\n    \nlinecolor\n   \n-->\n \n:\nblue\n\n\n\n\n\n\nThe \nseriestype\n is forced to be \n:path\n:\n\n\n    \nseriestype\n  \n:=\n  \n:\npath\n\n\n\n\n\n\nThe \nmarkershape\n is a little more complex; it checks the \nadd_marker\n custom keyword, but only if \nmarkershape\n was not already set.  (Note: the \nadd_marker\n key is redundant, as the user can just set the marker shape directly... I use it only for demonstration):\n\n\n    \nmarkershape\n \n-->\n \n(\nadd_marker\n \n?\n \n:\ncircle\n \n:\n \n:\nnone\n)\n\n\n\n\n\n\nthen return the data to be plotted:\n\n\n    \nrand\n(\nn\n)\n\n\nend\n\n\n\n\n\n\nSome example usages of our (mostly useless) recipe:\n\n\nmt\n \n=\n \nMyType\n()\n\n\nplot\n(\n\n    \nplot\n(\nmt\n),\n\n    \nplot\n(\nmt\n,\n \n100\n,\n \nlinecolor\n \n=\n \n:\nred\n),\n\n    \nplot\n(\nmt\n,\n \nmarker\n \n=\n \n(\n:\nstar\n,\n20\n),\n \nadd_marker\n \n=\n \nfalse\n),\n\n    \nplot\n(\nmt\n,\n \nadd_marker\n \n=\n \ntrue\n)\n\n\n)\n\n\n\n\n\n\n\n\n\n\nUser Recipes\n\n\nThe example above is an example of a \"user recipe\", in which you define the full signature for dispatch.  User recipes (like others) can be stacked and modular.  The following is valid:\n\n\n@recipe\n \nf\n(\nmt\n::\nMyType\n,\n \nn\n::\nInteger\n \n=\n \n10\n)\n \n=\n \n(\nmt\n,\n \nrand\n(\nn\n))\n\n\n@recipe\n \nf\n(\nmt\n::\nMyType\n,\n \nv\n::\nAbstractVector\n)\n \n=\n \nhist\n(\nv\n)\n\n\n\n\n\n\nHere a call to \nplot(MyType())\n will apply these recipes in order; first mapping \nmt\n to \n(mt, rand(10))\n and then subsequently mapping to \nhist(rand(10))\n.\n\n\n\n\nType Recipes\n\n\nFor some custom data types, they are essentially light wrappers around built-in containers.  For example you may have a type:\n\n\ntype\n \nMyWrapper\n\n    \nv\n::\nVector\n\n\nend\n\n\n\n\n\n\nIn this case, you'd like your \nMyWrapper\n objects to be treated just like Vectors, but do not wish to subtype AbstractArray.  No worries!  Just define a type recipe to do the conversion:\n\n\n@recipe\n \nf\n(\n::\nType\n{\nMyWrapper\n},\n \nmw\n::\nMyWrapper\n)\n \n=\n \nmw\n.\nv\n\n\n\n\n\n\nThis signature is called on each input when dispatch did not find a suitable recipe for the full \nargs...\n.  So \nplot(rand(10), MyWrapper(rand(10)))\n will \"just work\".\n\n\n\n\nSeries Recipes\n\n\nThis is where the magic happens.  You can create your own custom visualizations for arbitrary data.  Quickly define violin plots, error bars, and even standard types like histograms and step plots.  A histogram is a bar plot:\n\n\n@recipe\n \nfunction\n \nf\n(\n::\nType\n{\nVal\n{\n:\nhistogram\n}},\n \nx\n,\n \ny\n,\n \nz\n)\n\n    \nedges\n,\n \ncounts\n \n=\n \nmy_hist\n(\ny\n,\n \nplotattributes\n[\n:\nbins\n],\n\n                               \nnormed\n \n=\n \nplotattributes\n[\n:\nnormalize\n],\n\n                               \nweights\n \n=\n \nplotattributes\n[\n:\nweights\n])\n\n    \nx\n \n:=\n \nedges\n\n    \ny\n \n:=\n \ncounts\n\n    \nseriestype\n \n:=\n \n:\nbar\n\n    \n()\n\n\nend\n\n\n\n\n\n\nwhile a 2D histogram is really a heatmap:\n\n\n@recipe\n \nfunction\n \nf\n(\n::\nType\n{\nVal\n{\n:\nhistogram2d\n}},\n \nx\n,\n \ny\n,\n \nz\n)\n\n    \nxedges\n,\n \nyedges\n,\n \ncounts\n \n=\n \nmy_hist_2d\n(\nx\n,\n \ny\n,\n \nplotattributes\n[\n:\nbins\n],\n\n                                              \nnormed\n \n=\n \nplotattributes\n[\n:\nnormalize\n],\n\n                                              \nweights\n \n=\n \nplotattributes\n[\n:\nweights\n])\n\n    \nx\n \n:=\n \ncenters\n(\nxedges\n)\n\n    \ny\n \n:=\n \ncenters\n(\nyedges\n)\n\n    \nz\n \n:=\n \nSurface\n(\ncounts\n)\n\n    \nseriestype\n \n:=\n \n:\nheatmap\n\n    \n()\n\n\nend\n\n\n\n\n\n\nThe argument \ny\n is always populated, the argument \nx\n is populated with a call like \nplot(x,y, seriestype =: histogram2d)\n and correspondingly for \nz\n, \nplot(x,y,z, seriestype =: histogram2d)\n\n\nSee below where I go through a series recipe for creating boxplots.  Many of these \"standard\" recipes are defined in Plots, though they can be defined anywhere \nwithout requiring the package to be dependent on Plots\n.\n\n\n\n\nCase studies\n\n\nMarginal Histograms\n\n\nIn this case study, I'll explain how I built the \nmarginalhist\n recipe for \nPlotRecipes\n.  This is a nice example because, although easy to understand, it utilizes some great Plots features.\n\n\nMarginal histograms are a visualization comparing two variables.  The main plot is a 2D histogram, where each rectangle is a (possibly normalized and weighted) count of data points in that bucket.  Above the main plot is a smaller histogram of the first variable, and to the right of the main plot is a histogram of the second variable.  The full recipe:\n\n\n@userplot\n \nMarginalHist\n\n\n\n@recipe\n \nfunction\n \nf\n(\nh\n::\nMarginalHist\n)\n\n    \nif\n \nlength\n(\nh\n.\nargs\n)\n \n!=\n \n2\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n1\n])\n \n<:\n \nAbstractVector\n)\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n2\n])\n \n<:\n \nAbstractVector\n)\n\n        \nerror\n(\n\"Marginal Histograms should be given two vectors.  Got: \n$\n(\ntypeof\n(\nh\n.\nargs\n))\n\"\n)\n\n    \nend\n\n    \nx\n,\n \ny\n \n=\n \nh\n.\nargs\n\n\n    \n# set up the subplots\n\n    \nlegend\n \n:=\n \nfalse\n\n    \nlink\n \n:=\n \n:\nboth\n\n    \nticks\n \n:=\n \n[\nnothing\n \n:\nauto\n \nnothing\n]\n\n    \ngrid\n \n:=\n \nfalse\n\n    \nforeground_color_subplot\n \n:=\n \n[\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)\n \n:\nmatch\n \nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)]\n\n    \nlayout\n \n:=\n \n@layout\n \n[\ntophist\n           \n_\n\n                       \nhist2d\n{\n0.9\nw\n,\n0.9\nh\n}\n \nrighthist\n]\n\n\n    \n# main histogram2d\n\n    \n@series\n \nbegin\n\n        \nseriestype\n \n:=\n \n:\nhistogram2d\n\n        \nsubplot\n \n:=\n \n2\n\n        \nx\n,\n \ny\n\n    \nend\n\n\n    \n# these are common to both marginal histograms\n\n    \nfillcolor\n \n:=\n \n:\nblack\n\n    \nfillalpha\n \n:=\n \n0.3\n\n    \nlinealpha\n \n:=\n \n0.3\n\n    \nseriestype\n \n:=\n \n:\nhistogram\n\n\n    \n# upper histogram\n\n    \n@series\n \nbegin\n\n        \nsubplot\n \n:=\n \n1\n\n        \nx\n\n    \nend\n\n\n    \n# right histogram\n\n    \n@series\n \nbegin\n\n        \norientation\n \n:=\n \n:\nh\n\n        \nsubplot\n \n:=\n \n3\n\n        \ny\n\n    \nend\n\n\nend\n\n\n\n\n\n\nUsage:\n\n\nusing\n \nDistributions\n,\n \nPlotRecipes\n\n\npyplot\n()\n\n\nn\n \n=\n \n1000\n\n\nx\n \n=\n \nrand\n(\nGamma\n(\n2\n),\n \nn\n)\n\n\ny\n \n=\n \n-\n0.5\nx\n \n+\n \nrandn\n(\nn\n)\n\n\nmarginalhist\n(\nx\n,\n \ny\n,\n \nfc\n=:\nplasma\n,\n \nbins\n=\n40\n)\n\n\n\n\n\n\n\n\n\n\nNow I'll go through each section in detail:\n\n\nThe \n@userplot\n macro is a nice convenience for creating a new wrapper for input arguments that can be distinct during dispatch.  It also creates lowercase convenience methods (\nmarginalhist\n and \nmarginalhist!\n) and exports them.\n\n\n@userplot\n \nMarginalHist\n\n\n\n\n\n\nthus create a type \nMarginalHist\n for dispatch. An object of type \nMarginalHist\n has the field \nargs\n which is the tuple of arguments the plot function is invoked with, which can be either \nmarginalhist(x,y,...)\n or \nplot(x,y, seriestype = :marginalhist)\n. The first syntax is a shorthand created by the \n@userplot\n macro.\n\n\nWe dispatch only on the generated type, as the real inputs are wrapped inside it:\n\n\n@recipe\n \nfunction\n \nf\n(\nh\n::\nMarginalHist\n)\n\n\n\n\n\n\nSome error checking.  Note that we're extracting the real inputs (like in a call to \nmarginalhist(randn(100), randn(100))\n) into \nx\n and \ny\n:\n\n\n    \nif\n \nlength\n(\nh\n.\nargs\n)\n \n!=\n \n2\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n1\n])\n \n<:\n \nAbstractVector\n)\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n2\n])\n \n<:\n \nAbstractVector\n)\n\n        \nerror\n(\n\"Marginal Histograms should be given two vectors.  Got: \n$\n(\ntypeof\n(\nh\n.\nargs\n))\n\"\n)\n\n    \nend\n\n    \nx\n,\n \ny\n \n=\n \nh\n.\nargs\n\n\n\n\n\n\nNext we build the subplot layout and define some attributes.  A few things to note:\n\n\n- The layout creates three subplots (`_` is left blank)\n- Attributes are mapped to each subplot when passed in as a matrix (row-vector)\n- The attribute `link := :both` means that the y-axes of each row (and x-axes of\n    each column) will share data extrema.  Other values include `:x`, `:y`,\n    `:all`, and `:none`.\n\n\n\n\n\n    \n# set up the subplots\n\n    \nlegend\n \n:=\n \nfalse\n\n    \nlink\n \n:=\n \n:\nboth\n\n    \nticks\n \n:=\n \n[\nnothing\n \n:\nauto\n \nnothing\n]\n\n    \ngrid\n \n:=\n \nfalse\n\n    \nforeground_color_subplot\n \n:=\n \n[\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)\n \n:\nmatch\n \nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)]\n\n    \nlayout\n \n:=\n \n@layout\n \n[\ntophist\n           \n_\n\n                       \nhist2d\n{\n0.9\nw\n,\n0.9\nh\n}\n \nrighthist\n]\n\n\n\n\n\n\nDefine the series of the main plot.  The \n@series\n macro makes a local copy of the attribute dictionary \nd\n using a \"let block\".  The copied dictionary and the returned args are added to the \nVector{RecipeData}\n which is returned from the recipe.  This block is similar to calling \nhistogram2d!(x, y; subplot = 2, d...)\n (but you wouldn't actually want to do that).\n\n\nNote: this \n@series\n block gets a \"snapshot\" of the attributes, so it contains anything that was set before this block, but nothing from after it.  \n@series\n blocks can be standalone, as these are, or they can be in a loop.\n\n\n    \n# main histogram2d\n\n    \n@series\n \nbegin\n\n        \nseriestype\n \n:=\n \n:\nhistogram2d\n\n        \nsubplot\n \n:=\n \n2\n\n        \nx\n,\n \ny\n\n    \nend\n\n\n\n\n\n\nNext we move on to the marginal plots.  We first set attributes which are shared by both:\n\n\n    \n# these are common to both marginal histograms\n\n    \nfillcolor\n \n:=\n \n:\nblack\n\n    \nfillalpha\n \n:=\n \n0.3\n\n    \nlinealpha\n \n:=\n \n0.3\n\n    \nseriestype\n \n:=\n \n:\nhistogram\n\n\n\n\n\n\nNow we create two more series, one for each histogram.\n\n\n    \n# upper histogram\n\n    \n@series\n \nbegin\n\n        \nsubplot\n \n:=\n \n1\n\n        \nx\n\n    \nend\n\n\n    \n# right histogram\n\n    \n@series\n \nbegin\n\n        \norientation\n \n:=\n \n:\nh\n\n        \nsubplot\n \n:=\n \n3\n\n        \ny\n\n    \nend\n\n\nend\n\n\n\n\n\n\nIt's important to note: normally we would return arguments from a recipe, and those arguments would be added to a \nRecipeData\n object and pushed onto our \nVector{RecipeData}\n.  However, when creating series using the \n@series\n macro, you have the option of returning \nnothing\n, which will bypass that last step.\n\n\n\n\nSeries Recipe - Notched Box Plots\n\n\nTODO\n\n\n\n\nDocumenting plot functions\n\n\nA documentation string added above the recipe definition will have no effect, just like the function name is meaningless. Since everything in Julia can be associated with a doc-string, the documentation can be added to the name of the plot function like this\n\n\n\"\"\"\n\n\nMy docstring\n\n\n\"\"\"\n\n\nmy_plotfunc\n\n\n\n\n\n\nThis can be put anywhere in the code and will appear on the call \n?my_plotfunc\n.\n\n\n\n\nTroubleshooting\n\n\nIt can sometimes be helpful when debugging recipes to see the order of dispatch inside the \napply_recipe\n calls.  Turn on debugging info with:\n\n\nRecipesBase\n.\ndebug\n()\n\n\n\n\n\n\nYou can also pass a \nBool\n to the \ndebug\n method to turn it on/off.\n\n\nHere are some common errors, and what to look out for:\n\n\nconvertToAnyVector\n\n\nERROR\n:\n \nIn\n \nconvertToAnyVector\n,\n \ncould\n \nnot\n \nhandle\n \nthe\n \nargument\n \ntypes\n:\n \n<<\nsome\n \ntype\n>>\n\n    \n[\ninlined\n \ncode\n]\n \nfrom\n \n~/\n.\njulia\n/\nv0\n.4\n/\nPlots\n/\nsrc\n/\nseries_new\n.\njl\n:\n87\n\n    \nin\n \napply_recipe\n \nat\n \n~/\n.\njulia\n/\nv0\n.4\n/\nRecipesBase\n/\nsrc\n/\nRecipesBase\n.\njl\n:\n237\n\n    \nin\n \n_plot\n!\n \nat\n \n~/\n.\njulia\n/\nv0\n.4\n/\nPlots\n/\nsrc\n/\nplot\n.\njl\n:\n312\n\n    \nin\n \nplot\n \nat\n \n~/\n.\njulia\n/\nv0\n.4\n/\nPlots\n/\nsrc\n/\nplot\n.\njl\n:\n52\n\n\n\n\n\n\nThis error occurs when the input types could not be handled by a recipe. The type \n<<some type>>\n cannot be processed.  Remember, there may be recursive calls to multiple recipes for a complicated plot.\n\n\nMethodError: \nstart\n has no method matching start(::Void)\n\n\nERROR\n:\n \nMethodError\n:\n \n`\nstart\n`\n \nhas\n \nno\n \nmethod\n \nmatching\n \nstart\n(::\nVoid\n)\n\n    \nin\n \ncollect\n \nat\n \n./\narray\n.\njl\n:\n260\n\n    \nin\n \ncollect\n \nat\n \n./\narray\n.\njl\n:\n272\n\n    \nin\n \nplotly_series\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/backends/\nplotly\n.\njl\n:\n345\n\n    \nin\n \n_series_added\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/backends/\nplotlyjs\n.\njl\n:\n36\n\n    \nin\n \n_apply_series_recipe\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/\nplot\n.\njl\n:\n224\n\n    \nin\n \n_plot\n!\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/\nplot\n.\njl\n:\n537\n\n\n\n\n\n\nThis error is commonly encountered when a series type expects data for \nx\n, \ny\n, or \nz\n, but instead was passed \nnothing\n (which is of type \nVoid\n).  Check that you have a \nz\n value defined for 3D plots, and likewise that you have valid values for \nx\n and \ny\n.  This could also apply to attributes like \nfillrange\n, \nmarker_z\n, or \nline_z\n if they are expected to have non-void values.",
            "title": "Recipes"
        },
        {
            "location": "/recipes/#advanced-recipes",
            "text": "Like other tools in Plots, recipes are relatively simple, but extremely powerful.  A recipe is created by invoking the  @recipe  macro, which is defined in the lightweight package  RecipesBase .  There are many examples of recipes both within Plots and in many external packages, including  PlotRecipes .  There are four main types of recipes in Plots (listed in the order they are processed):   User Recipes  Type Recipes  Plot Recipes  Series Recipes   The recipe type is determined completely by the dispatch signature.   Each recipe type is called from a different part of the  plotting pipeline , so you will choose a type of recipe to match how much processing you want completed before your recipe is applied.  These are the dispatch signatures for each type (note that most of these can accept positional or keyword args, denoted by  ... ):   User Recipes:  @recipe function f(custom_arg_1::T, custom_arg_2::S, ...; ...) end  Process a unique set of types early in the pipeline.  Good for user-defined types or special combinations of Base types.  The  @userplot  macro is a nice convenience which both defines a new type (to ensure correct dispatch) and exports shorthands.  See  graphplot  for an example.    Type Recipes:  @recipe function f{T<:MyType}(::Type{T}, val::T) end  For user-defined types which wrap or have a one-to-one mapping to something supported by Plots, simply define a conversion method.  Note: this is effectively saying \"when you see type T, replace it with ...\"  See  SymPy  for an example.    Plot Recipes:  @recipe function f(::Type{Val{:myplotrecipename}}, plt::Plot; ...) end  These are called after input data has been processed, but  before the plot is created .  Build layouts, add subplots, and other plot-wide attributes  See  marginalhist  for an example.    Series Recipes:  @recipe function f(::Type{Val{:myseriesrecipename}}, x, y, z; ...) end  These are the last calls to happen.  Each backend will support a short list of series types ( path ,  shape ,  histogram , etc).  If a series type is natively supported, processing is passed (delegated) to the backend.  If a series type is  not  natively supported by the backend, we attempt to call a \"series recipe\".  Note: If there's no series recipe defined, and the backend doesn't support it, you'll see an error like:  ERROR: The backend must not support the series type Val{:hi}, and there isn't a series recipe defined.  Note: You must have the  x, y, z  included in the signature, or it won't be processed as a series type!!",
            "title": "Advanced Recipes"
        },
        {
            "location": "/recipes/#recipe-syntaxrules",
            "text": "Lets decompose what's happening inside the recipe macro, starting with a simple recipe:  type   MyType   end  @recipe   function   f ( :: MyType ,   n :: Integer   =   10 ;   add_marker   =   false ) \n     linecolor     -->   : blue \n     seriestype    :=    : path \n     markershape   -->   ( add_marker   ?   : circle   :   : none ) \n     delete! ( plotattributes ,   : add_marker ) \n     rand ( n )  end   We create a new type  MyType , which is empty, and used purely for dispatch.  Our goal here is to create a random path of  n  points.  There are a few important things to know, after which recipes boil down to updating an attribute dictionary and returning input data:   A recipe signature  f(args...; kw...)  is converted into a definition of  apply_recipe(plotattributes::KW, args...)  where:  plotattributes  is an attribute dictionary of type  typealias KW Dict{Symbol,Any}  Your  args  must be distinct enough that dispatch will call your definition (and without masking an existing definition).  Using a custom data type will ensure proper dispatch.  The function  f  is unused/meaningless... call it whatever you want.    The special operator  -->  turns  linecolor --> :blue  into  get!(plotattributes, :linecolor, :blue) , setting the attribute only when it doesn't already exist.  (Tip: Wrap the right hand side in parentheses for complex expressions.)  The special operator  :=  turns  seriestype := :path  into  plotattributes[:seriestype] = :path , forcing that attribute value.  (Tip: Wrap the right hand side in parentheses for complex expressions.)  The return value of the recipe is the  args  of a  RecipeData  object, which also has a reference to the attribute dictionary.  A recipe returns a Vector{RecipeData}.  We'll see how to add to this list later with the  @series  macro.   Breaking down the example:  In the example above, we use  MyType  for dispatch, with optional positional argument  n::Integer :  @recipe   function   f ( :: MyType ,   n :: Integer   =   10 ;   add_marker   =   false )   With a call to  plot(MyType())  or similar, this recipe will be invoked.  If  linecolor  has not been set, it is set to  :blue :       linecolor     -->   : blue   The  seriestype  is forced to be  :path :       seriestype    :=    : path   The  markershape  is a little more complex; it checks the  add_marker  custom keyword, but only if  markershape  was not already set.  (Note: the  add_marker  key is redundant, as the user can just set the marker shape directly... I use it only for demonstration):       markershape   -->   ( add_marker   ?   : circle   :   : none )   then return the data to be plotted:       rand ( n )  end   Some example usages of our (mostly useless) recipe:  mt   =   MyType ()  plot ( \n     plot ( mt ), \n     plot ( mt ,   100 ,   linecolor   =   : red ), \n     plot ( mt ,   marker   =   ( : star , 20 ),   add_marker   =   false ), \n     plot ( mt ,   add_marker   =   true )  )",
            "title": "Recipe Syntax/Rules"
        },
        {
            "location": "/recipes/#user-recipes",
            "text": "The example above is an example of a \"user recipe\", in which you define the full signature for dispatch.  User recipes (like others) can be stacked and modular.  The following is valid:  @recipe   f ( mt :: MyType ,   n :: Integer   =   10 )   =   ( mt ,   rand ( n ))  @recipe   f ( mt :: MyType ,   v :: AbstractVector )   =   hist ( v )   Here a call to  plot(MyType())  will apply these recipes in order; first mapping  mt  to  (mt, rand(10))  and then subsequently mapping to  hist(rand(10)) .",
            "title": "User Recipes"
        },
        {
            "location": "/recipes/#type-recipes",
            "text": "For some custom data types, they are essentially light wrappers around built-in containers.  For example you may have a type:  type   MyWrapper \n     v :: Vector  end   In this case, you'd like your  MyWrapper  objects to be treated just like Vectors, but do not wish to subtype AbstractArray.  No worries!  Just define a type recipe to do the conversion:  @recipe   f ( :: Type { MyWrapper },   mw :: MyWrapper )   =   mw . v   This signature is called on each input when dispatch did not find a suitable recipe for the full  args... .  So  plot(rand(10), MyWrapper(rand(10)))  will \"just work\".",
            "title": "Type Recipes"
        },
        {
            "location": "/recipes/#series-recipes",
            "text": "This is where the magic happens.  You can create your own custom visualizations for arbitrary data.  Quickly define violin plots, error bars, and even standard types like histograms and step plots.  A histogram is a bar plot:  @recipe   function   f ( :: Type { Val { : histogram }},   x ,   y ,   z ) \n     edges ,   counts   =   my_hist ( y ,   plotattributes [ : bins ], \n                                normed   =   plotattributes [ : normalize ], \n                                weights   =   plotattributes [ : weights ]) \n     x   :=   edges \n     y   :=   counts \n     seriestype   :=   : bar \n     ()  end   while a 2D histogram is really a heatmap:  @recipe   function   f ( :: Type { Val { : histogram2d }},   x ,   y ,   z ) \n     xedges ,   yedges ,   counts   =   my_hist_2d ( x ,   y ,   plotattributes [ : bins ], \n                                               normed   =   plotattributes [ : normalize ], \n                                               weights   =   plotattributes [ : weights ]) \n     x   :=   centers ( xedges ) \n     y   :=   centers ( yedges ) \n     z   :=   Surface ( counts ) \n     seriestype   :=   : heatmap \n     ()  end   The argument  y  is always populated, the argument  x  is populated with a call like  plot(x,y, seriestype =: histogram2d)  and correspondingly for  z ,  plot(x,y,z, seriestype =: histogram2d)  See below where I go through a series recipe for creating boxplots.  Many of these \"standard\" recipes are defined in Plots, though they can be defined anywhere  without requiring the package to be dependent on Plots .",
            "title": "Series Recipes"
        },
        {
            "location": "/recipes/#case-studies",
            "text": "",
            "title": "Case studies"
        },
        {
            "location": "/recipes/#marginal-histograms",
            "text": "In this case study, I'll explain how I built the  marginalhist  recipe for  PlotRecipes .  This is a nice example because, although easy to understand, it utilizes some great Plots features.  Marginal histograms are a visualization comparing two variables.  The main plot is a 2D histogram, where each rectangle is a (possibly normalized and weighted) count of data points in that bucket.  Above the main plot is a smaller histogram of the first variable, and to the right of the main plot is a histogram of the second variable.  The full recipe:  @userplot   MarginalHist  @recipe   function   f ( h :: MarginalHist ) \n     if   length ( h . args )   !=   2   ||   ! ( typeof ( h . args [ 1 ])   <:   AbstractVector )   ||   ! ( typeof ( h . args [ 2 ])   <:   AbstractVector ) \n         error ( \"Marginal Histograms should be given two vectors.  Got:  $ ( typeof ( h . args )) \" ) \n     end \n     x ,   y   =   h . args \n\n     # set up the subplots \n     legend   :=   false \n     link   :=   : both \n     ticks   :=   [ nothing   : auto   nothing ] \n     grid   :=   false \n     foreground_color_subplot   :=   [ RGBA ( 0 , 0 , 0 , 0 )   : match   RGBA ( 0 , 0 , 0 , 0 )] \n     layout   :=   @layout   [ tophist             _ \n                        hist2d { 0.9 w , 0.9 h }   righthist ] \n\n     # main histogram2d \n     @series   begin \n         seriestype   :=   : histogram2d \n         subplot   :=   2 \n         x ,   y \n     end \n\n     # these are common to both marginal histograms \n     fillcolor   :=   : black \n     fillalpha   :=   0.3 \n     linealpha   :=   0.3 \n     seriestype   :=   : histogram \n\n     # upper histogram \n     @series   begin \n         subplot   :=   1 \n         x \n     end \n\n     # right histogram \n     @series   begin \n         orientation   :=   : h \n         subplot   :=   3 \n         y \n     end  end   Usage:  using   Distributions ,   PlotRecipes  pyplot ()  n   =   1000  x   =   rand ( Gamma ( 2 ),   n )  y   =   - 0.5 x   +   randn ( n )  marginalhist ( x ,   y ,   fc =: plasma ,   bins = 40 )     Now I'll go through each section in detail:  The  @userplot  macro is a nice convenience for creating a new wrapper for input arguments that can be distinct during dispatch.  It also creates lowercase convenience methods ( marginalhist  and  marginalhist! ) and exports them.  @userplot   MarginalHist   thus create a type  MarginalHist  for dispatch. An object of type  MarginalHist  has the field  args  which is the tuple of arguments the plot function is invoked with, which can be either  marginalhist(x,y,...)  or  plot(x,y, seriestype = :marginalhist) . The first syntax is a shorthand created by the  @userplot  macro.  We dispatch only on the generated type, as the real inputs are wrapped inside it:  @recipe   function   f ( h :: MarginalHist )   Some error checking.  Note that we're extracting the real inputs (like in a call to  marginalhist(randn(100), randn(100)) ) into  x  and  y :       if   length ( h . args )   !=   2   ||   ! ( typeof ( h . args [ 1 ])   <:   AbstractVector )   ||   ! ( typeof ( h . args [ 2 ])   <:   AbstractVector ) \n         error ( \"Marginal Histograms should be given two vectors.  Got:  $ ( typeof ( h . args )) \" ) \n     end \n     x ,   y   =   h . args   Next we build the subplot layout and define some attributes.  A few things to note:  - The layout creates three subplots (`_` is left blank)\n- Attributes are mapped to each subplot when passed in as a matrix (row-vector)\n- The attribute `link := :both` means that the y-axes of each row (and x-axes of\n    each column) will share data extrema.  Other values include `:x`, `:y`,\n    `:all`, and `:none`.       # set up the subplots \n     legend   :=   false \n     link   :=   : both \n     ticks   :=   [ nothing   : auto   nothing ] \n     grid   :=   false \n     foreground_color_subplot   :=   [ RGBA ( 0 , 0 , 0 , 0 )   : match   RGBA ( 0 , 0 , 0 , 0 )] \n     layout   :=   @layout   [ tophist             _ \n                        hist2d { 0.9 w , 0.9 h }   righthist ]   Define the series of the main plot.  The  @series  macro makes a local copy of the attribute dictionary  d  using a \"let block\".  The copied dictionary and the returned args are added to the  Vector{RecipeData}  which is returned from the recipe.  This block is similar to calling  histogram2d!(x, y; subplot = 2, d...)  (but you wouldn't actually want to do that).  Note: this  @series  block gets a \"snapshot\" of the attributes, so it contains anything that was set before this block, but nothing from after it.   @series  blocks can be standalone, as these are, or they can be in a loop.       # main histogram2d \n     @series   begin \n         seriestype   :=   : histogram2d \n         subplot   :=   2 \n         x ,   y \n     end   Next we move on to the marginal plots.  We first set attributes which are shared by both:       # these are common to both marginal histograms \n     fillcolor   :=   : black \n     fillalpha   :=   0.3 \n     linealpha   :=   0.3 \n     seriestype   :=   : histogram   Now we create two more series, one for each histogram.       # upper histogram \n     @series   begin \n         subplot   :=   1 \n         x \n     end \n\n     # right histogram \n     @series   begin \n         orientation   :=   : h \n         subplot   :=   3 \n         y \n     end  end   It's important to note: normally we would return arguments from a recipe, and those arguments would be added to a  RecipeData  object and pushed onto our  Vector{RecipeData} .  However, when creating series using the  @series  macro, you have the option of returning  nothing , which will bypass that last step.",
            "title": "Marginal Histograms"
        },
        {
            "location": "/recipes/#series-recipe-notched-box-plots",
            "text": "TODO",
            "title": "Series Recipe - Notched Box Plots"
        },
        {
            "location": "/recipes/#documenting-plot-functions",
            "text": "A documentation string added above the recipe definition will have no effect, just like the function name is meaningless. Since everything in Julia can be associated with a doc-string, the documentation can be added to the name of the plot function like this  \"\"\"  My docstring  \"\"\"  my_plotfunc   This can be put anywhere in the code and will appear on the call  ?my_plotfunc .",
            "title": "Documenting plot functions"
        },
        {
            "location": "/recipes/#troubleshooting",
            "text": "It can sometimes be helpful when debugging recipes to see the order of dispatch inside the  apply_recipe  calls.  Turn on debugging info with:  RecipesBase . debug ()   You can also pass a  Bool  to the  debug  method to turn it on/off.  Here are some common errors, and what to look out for:",
            "title": "Troubleshooting"
        },
        {
            "location": "/recipes/#converttoanyvector",
            "text": "ERROR :   In   convertToAnyVector ,   could   not   handle   the   argument   types :   << some   type >> \n     [ inlined   code ]   from   ~/ . julia / v0 .4 / Plots / src / series_new . jl : 87 \n     in   apply_recipe   at   ~/ . julia / v0 .4 / RecipesBase / src / RecipesBase . jl : 237 \n     in   _plot !   at   ~/ . julia / v0 .4 / Plots / src / plot . jl : 312 \n     in   plot   at   ~/ . julia / v0 .4 / Plots / src / plot . jl : 52   This error occurs when the input types could not be handled by a recipe. The type  <<some type>>  cannot be processed.  Remember, there may be recursive calls to multiple recipes for a complicated plot.",
            "title": "convertToAnyVector"
        },
        {
            "location": "/recipes/#methoderror-start-has-no-method-matching-startvoid",
            "text": "ERROR :   MethodError :   ` start `   has   no   method   matching   start (:: Void ) \n     in   collect   at   ./ array . jl : 260 \n     in   collect   at   ./ array . jl : 272 \n     in   plotly_series   at   ~/. julia /v0.4/Plots/src/backends/ plotly . jl : 345 \n     in   _series_added   at   ~/. julia /v0.4/Plots/src/backends/ plotlyjs . jl : 36 \n     in   _apply_series_recipe   at   ~/. julia /v0.4/Plots/src/ plot . jl : 224 \n     in   _plot !   at   ~/. julia /v0.4/Plots/src/ plot . jl : 537   This error is commonly encountered when a series type expects data for  x ,  y , or  z , but instead was passed  nothing  (which is of type  Void ).  Check that you have a  z  value defined for 3D plots, and likewise that you have valid values for  x  and  y .  This could also apply to attributes like  fillrange ,  marker_z , or  line_z  if they are expected to have non-void values.",
            "title": "MethodError: start has no method matching start(::Void)"
        },
        {
            "location": "/plots_v0.7/",
            "text": "Plots - New and improved\n\n\nJust as Gregor Clegane went from \npowerful man\n to \nunstoppable monster\n, Plots is making a transition to a more modular, more powerful, and more customizable visualization platform.\n\n\nThere are two major shifts (recipes and layouts) and countless other smaller changes.  Internally, things look very different, but I've made serious effort to keep things backward-compatible, when appropriate.\n\n\n\n\nRecipes\n\n\nSee \nthe full recipes tutorial\n for a detailed explanation.\n\n\nSparked by a brief comment by @Evizero (Christof Stocker) during a discussion on a Plots issue, the importance of recipes for the future of plotting in Julia became immediately apparent.  I went to work right away to build \nRecipesBase\n, a super lightweight but powerful package which allows users to create intricate plotting logic external to Plots.  The \n@recipe\n macro in RecipesBase will add a method definition for \nRecipesBase.apply_recipe\n.  Plots adds to and calls this same function, and so your package and Plots can communicate without ever knowing about the other.  Magic!\n\n\nVisualizing custom user types has always been a confusing problem.  Should a package developer add a dependency on a plotting package (forcing the significant baggage that comes with that dependency)? Should they attempt conditional dependencies?  Should they submit a PR to graphics packages to define their custom visualizations?  It seems that every option had many cons for each pro, and the decision was tough.  With recipes, these issues go away.  One tiny package (RecipesBase) gives simple hooks into the visualization pipeline, allowing users and package developers to focus solely on the specifics of their visualization.  Pick the shapes/lines/colors that will represent your data well, decide on custom defaults, and convert the inputs (if you need to).  Everything else is handled by Plots.\n\n\nVisualizing User Types\n\n\nExamples are always best.  Lets explore the implementation of \ncreating visualization recipes for Distributions\n.\n\n\nCustom treatment of input combinations\n\n\nWant to do something special whenever the first input is a time series?  Maybe you want to preprocess your data depending on keyword flags?  This is all possible by making recipes with unique dispatch signatures.  You can offload and use the pre and post processing of Plots, and just add the bits that are specific to you.\n\n\nType Recipes: Easy drop-in replacement of data types\n\n\nMany times a data type is a simple wrapper of a Function or Array.  For example:\n\n\ntype\n \nMyVec\n\n    \nv\n::\nVector\n{\nInt\n}\n\n\nend\n\n\n\n\n\n\nIf \nMyVec\n was a subtype of AbstractVector, there would not be anything to do... it should \"just work\".  However this isn't always desireable, and it would be nice if you could call \nplot(10:20, myvec)\n without having to personally define every possible combination of inputs.  It this case, you'll want to use a special type of recipe signature:\n\n\n@recipe\n \nf\n(\n::\nType\n{\nMyVec\n},\n \nmyvec\n::\nMyVec\n)\n \n=\n \nmyvec\n.\nv\n\n\n\n\n\n\nAfterwards, all plot commands which work for vectors will also work for your datatype.\n\n\nSeries Recipes\n\n\nLets quickly discuss a mainstay of data visualization: the histogram.  Hadley Wickham has explored the nature of histograms as part of his \nLayered Grammar of Graphics\n.  In it, he discusses how a histogram is really nothing more than a bar graph which has its data pre-binned.  This is true, and it can be taken further.  A bar-graph is really an extension of a step-graph, in which zeros are interwoven among the x-values.  A step-graph is really nothing more than a path (line) which can travel only horizontally or vertically.  Of course, a similar decomposition could be had by treating the bars as filled polygons.\n\n\nThe point to be had is that a graphics package need only be able to draw lines and polygons, and they can support drawing a histogram.  The path from data to histogram is normally very complicated, but we can avoid the complexity and define a recipe to convert it to its subcomponents.  In a few lines of readable code, we can implement a key statistical visualization.  See the \ntutorial on series recipes\n for a better understanding of how you might use them.\n\n\n\n\nLayouts\n\n\nSee the \ntutorial on layouts\n.\n\n\n\n\nEverything else\n\n\nSee the \nNEWS\n.",
            "title": "Plots v0.7"
        },
        {
            "location": "/plots_v0.7/#plots-new-and-improved",
            "text": "Just as Gregor Clegane went from  powerful man  to  unstoppable monster , Plots is making a transition to a more modular, more powerful, and more customizable visualization platform.  There are two major shifts (recipes and layouts) and countless other smaller changes.  Internally, things look very different, but I've made serious effort to keep things backward-compatible, when appropriate.",
            "title": "Plots - New and improved"
        },
        {
            "location": "/plots_v0.7/#recipes",
            "text": "See  the full recipes tutorial  for a detailed explanation.  Sparked by a brief comment by @Evizero (Christof Stocker) during a discussion on a Plots issue, the importance of recipes for the future of plotting in Julia became immediately apparent.  I went to work right away to build  RecipesBase , a super lightweight but powerful package which allows users to create intricate plotting logic external to Plots.  The  @recipe  macro in RecipesBase will add a method definition for  RecipesBase.apply_recipe .  Plots adds to and calls this same function, and so your package and Plots can communicate without ever knowing about the other.  Magic!  Visualizing custom user types has always been a confusing problem.  Should a package developer add a dependency on a plotting package (forcing the significant baggage that comes with that dependency)? Should they attempt conditional dependencies?  Should they submit a PR to graphics packages to define their custom visualizations?  It seems that every option had many cons for each pro, and the decision was tough.  With recipes, these issues go away.  One tiny package (RecipesBase) gives simple hooks into the visualization pipeline, allowing users and package developers to focus solely on the specifics of their visualization.  Pick the shapes/lines/colors that will represent your data well, decide on custom defaults, and convert the inputs (if you need to).  Everything else is handled by Plots.",
            "title": "Recipes"
        },
        {
            "location": "/plots_v0.7/#visualizing-user-types",
            "text": "Examples are always best.  Lets explore the implementation of  creating visualization recipes for Distributions .",
            "title": "Visualizing User Types"
        },
        {
            "location": "/plots_v0.7/#custom-treatment-of-input-combinations",
            "text": "Want to do something special whenever the first input is a time series?  Maybe you want to preprocess your data depending on keyword flags?  This is all possible by making recipes with unique dispatch signatures.  You can offload and use the pre and post processing of Plots, and just add the bits that are specific to you.",
            "title": "Custom treatment of input combinations"
        },
        {
            "location": "/plots_v0.7/#type-recipes-easy-drop-in-replacement-of-data-types",
            "text": "Many times a data type is a simple wrapper of a Function or Array.  For example:  type   MyVec \n     v :: Vector { Int }  end   If  MyVec  was a subtype of AbstractVector, there would not be anything to do... it should \"just work\".  However this isn't always desireable, and it would be nice if you could call  plot(10:20, myvec)  without having to personally define every possible combination of inputs.  It this case, you'll want to use a special type of recipe signature:  @recipe   f ( :: Type { MyVec },   myvec :: MyVec )   =   myvec . v   Afterwards, all plot commands which work for vectors will also work for your datatype.",
            "title": "Type Recipes: Easy drop-in replacement of data types"
        },
        {
            "location": "/plots_v0.7/#series-recipes",
            "text": "Lets quickly discuss a mainstay of data visualization: the histogram.  Hadley Wickham has explored the nature of histograms as part of his  Layered Grammar of Graphics .  In it, he discusses how a histogram is really nothing more than a bar graph which has its data pre-binned.  This is true, and it can be taken further.  A bar-graph is really an extension of a step-graph, in which zeros are interwoven among the x-values.  A step-graph is really nothing more than a path (line) which can travel only horizontally or vertically.  Of course, a similar decomposition could be had by treating the bars as filled polygons.  The point to be had is that a graphics package need only be able to draw lines and polygons, and they can support drawing a histogram.  The path from data to histogram is normally very complicated, but we can avoid the complexity and define a recipe to convert it to its subcomponents.  In a few lines of readable code, we can implement a key statistical visualization.  See the  tutorial on series recipes  for a better understanding of how you might use them.",
            "title": "Series Recipes"
        },
        {
            "location": "/plots_v0.7/#layouts",
            "text": "See the  tutorial on layouts .",
            "title": "Layouts"
        },
        {
            "location": "/plots_v0.7/#everything-else",
            "text": "See the  NEWS .",
            "title": "Everything else"
        },
        {
            "location": "/ecosystem/",
            "text": "Plots is great on its own, but the real power comes from the ecosystem surrounding it.  The design of Plots (and more specifically \nRecipesBase\n) is to bind together disparate functionality into a cohesive and consistent user experience.  Some packages may choose to implement recipes to visualize their custom types.  Others may extend the functionality of Plots for Base types.  On this page I'll attempt to collect and display some of the many things you can do using the ecosystem which has developed around the Plots core.\n\n\n\n\nJuliaPlots\n\n\nThe \nJuliaPlots\n organization builds and maintains much of the most commonly used functionality external to core Plots, as well as RecipesBase, PlotUtils, the documentation, and more.\n\n\nStatPlots\n\n\nMuch of this functionality once existed in core Plots, but has been moved out to facilitate a clean separation between those features that are truly \"core\" and those which are specific to certain types of workflows and disciplines.  \n\n\n\n\nTypes:\n\n\nDataFrames\n\n\nDistributions\n\n\n\n\n\n\nRecipes:\n\n\nhistogram/histogram2d\n\n\nboxplot\n\n\nviolin\n\n\nmarginalhist\n\n\ncorrplot/cornerplot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlotRecipes\n\n\nA catch-all for functionality and recipes which don't have a home elsewhere.  Graphs (networks of nodes and edges), maps/shapes, finance, and more.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCommunity packages\n\n\nAtariAlgos\n\n\nAtariAlgos wraps the ArcadeLearningEnvironment as an implementation of an AbstractEnvironment from the Reinforce interface. This allows it to be used as a plug-and-play module with general reinforcement learning agents.\n\n\nGames can also be \"plotted\" using Plots.jl, allowing it to be a component of more complex visualizations for tracking learning progress and more, as well as making it easy to create animations.\n\n\n\n\nReinforce\n\n\nReinforce.jl is an interface for Reinforcement Learning. It is intended to connect modular environments, policies, and solvers with a simple interface.\n\n\n\n\nJuliaML\n\n\nTools, models, and math related to machine learning in Julia.\n\n\n\n\nAugmentor\n\n\nAugmentor is an image-augmentation library designed to render the process of artificial dataset enlargement more convenient, less error prone, and easier to reproduce. This is achieved using probabilistic transformation pipelines.\n\n\n\n\nDifferentialEquations\n\n\nDifferentialEquations.jl is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes well-optimized implementations classic algorithms and ones from recent research, including algorithms optimized for high-precision and HPC applications.\n\n\nAll of the solvers return solution objects which are set up with plot recipes to give informative default plots.\n\n\n\n\nPhyloTrees\n\n\nThe PhyloTrees.jl package provides a type representation of phylogenetic trees. Simulation, inference, and visualization functionality is also provided for phylogenetic trees. A plot recipe allows the structure of phylogenetic trees to be drawn by whichever plotting backend is preferred by the user.\n\n\n\n\nEEG\n\n\nProcess EEG files and visualize brain activity.\n\n\n\n\n\n\nImplicitEquations\n\n\nIn a paper, Tupper presents a method for graphing two-dimensional implicit equations and inequalities. This package gives an implementation of the paper's basic algorithms to allow the Julia user to naturally represent and easily render graphs of implicit functions and equations.\n\n\n\n\nControlSystems\n\n\nA control systems design toolbox for Julia.  This toolbox works similar to that of other major computer-aided control systems design (CACSD) toolboxes. Systems can be created in either a transfer function or a state space representation. These systems can then be combined into larger architectures, simulated in both time and frequency domain, and analyzed for stability/performance properties.\n\n\n\n\nValueHistories\n\n\nUtility package for efficient tracking of optimization histories, training curves or other information of arbitrary types and at arbitrarily spaced sampling times\n\n\n\n\nApproxFun\n\n\nApproxFun is a package for approximating functions. It is heavily influenced by the Matlab package Chebfun and the Mathematica package RHPackage.\n\n\n\n\nAverageShiftedHistograms\n\n\nDensity estimation using Average Shifted Histograms.\n\n\n\n\nMLPlots\n\n\nCommon plotting recipes for statistics and machine learning.\n\n\n\n\n\n\nTODO:\n\n\nLosses\n\n\nIterativeSolvers\n\n\nSymPy\n\n\nOnlineStats\n\n\nRobotlib\n\n\nJWAS\n\n\nQuantEcon\n\n\nReinforce\n\n\nOptim\n\n\nTransformations / Flow",
            "title": "Ecosystem"
        },
        {
            "location": "/ecosystem/#juliaplots",
            "text": "The  JuliaPlots  organization builds and maintains much of the most commonly used functionality external to core Plots, as well as RecipesBase, PlotUtils, the documentation, and more.",
            "title": "JuliaPlots"
        },
        {
            "location": "/ecosystem/#statplots",
            "text": "Much of this functionality once existed in core Plots, but has been moved out to facilitate a clean separation between those features that are truly \"core\" and those which are specific to certain types of workflows and disciplines.     Types:  DataFrames  Distributions    Recipes:  histogram/histogram2d  boxplot  violin  marginalhist  corrplot/cornerplot",
            "title": "StatPlots"
        },
        {
            "location": "/ecosystem/#plotrecipes",
            "text": "A catch-all for functionality and recipes which don't have a home elsewhere.  Graphs (networks of nodes and edges), maps/shapes, finance, and more.",
            "title": "PlotRecipes"
        },
        {
            "location": "/ecosystem/#community-packages",
            "text": "",
            "title": "Community packages"
        },
        {
            "location": "/ecosystem/#atarialgos",
            "text": "AtariAlgos wraps the ArcadeLearningEnvironment as an implementation of an AbstractEnvironment from the Reinforce interface. This allows it to be used as a plug-and-play module with general reinforcement learning agents.  Games can also be \"plotted\" using Plots.jl, allowing it to be a component of more complex visualizations for tracking learning progress and more, as well as making it easy to create animations.",
            "title": "AtariAlgos"
        },
        {
            "location": "/ecosystem/#reinforce",
            "text": "Reinforce.jl is an interface for Reinforcement Learning. It is intended to connect modular environments, policies, and solvers with a simple interface.",
            "title": "Reinforce"
        },
        {
            "location": "/ecosystem/#juliaml",
            "text": "Tools, models, and math related to machine learning in Julia.",
            "title": "JuliaML"
        },
        {
            "location": "/ecosystem/#augmentor",
            "text": "Augmentor is an image-augmentation library designed to render the process of artificial dataset enlargement more convenient, less error prone, and easier to reproduce. This is achieved using probabilistic transformation pipelines.",
            "title": "Augmentor"
        },
        {
            "location": "/ecosystem/#differentialequations",
            "text": "DifferentialEquations.jl is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes well-optimized implementations classic algorithms and ones from recent research, including algorithms optimized for high-precision and HPC applications.  All of the solvers return solution objects which are set up with plot recipes to give informative default plots.",
            "title": "DifferentialEquations"
        },
        {
            "location": "/ecosystem/#phylotrees",
            "text": "The PhyloTrees.jl package provides a type representation of phylogenetic trees. Simulation, inference, and visualization functionality is also provided for phylogenetic trees. A plot recipe allows the structure of phylogenetic trees to be drawn by whichever plotting backend is preferred by the user.",
            "title": "PhyloTrees"
        },
        {
            "location": "/ecosystem/#eeg",
            "text": "Process EEG files and visualize brain activity.",
            "title": "EEG"
        },
        {
            "location": "/ecosystem/#implicitequations",
            "text": "In a paper, Tupper presents a method for graphing two-dimensional implicit equations and inequalities. This package gives an implementation of the paper's basic algorithms to allow the Julia user to naturally represent and easily render graphs of implicit functions and equations.",
            "title": "ImplicitEquations"
        },
        {
            "location": "/ecosystem/#controlsystems",
            "text": "A control systems design toolbox for Julia.  This toolbox works similar to that of other major computer-aided control systems design (CACSD) toolboxes. Systems can be created in either a transfer function or a state space representation. These systems can then be combined into larger architectures, simulated in both time and frequency domain, and analyzed for stability/performance properties.",
            "title": "ControlSystems"
        },
        {
            "location": "/ecosystem/#valuehistories",
            "text": "Utility package for efficient tracking of optimization histories, training curves or other information of arbitrary types and at arbitrarily spaced sampling times",
            "title": "ValueHistories"
        },
        {
            "location": "/ecosystem/#approxfun",
            "text": "ApproxFun is a package for approximating functions. It is heavily influenced by the Matlab package Chebfun and the Mathematica package RHPackage.",
            "title": "ApproxFun"
        },
        {
            "location": "/ecosystem/#averageshiftedhistograms",
            "text": "Density estimation using Average Shifted Histograms.",
            "title": "AverageShiftedHistograms"
        },
        {
            "location": "/ecosystem/#mlplots",
            "text": "Common plotting recipes for statistics and machine learning.    TODO:",
            "title": "MLPlots"
        },
        {
            "location": "/ecosystem/#losses",
            "text": "",
            "title": "Losses"
        },
        {
            "location": "/ecosystem/#iterativesolvers",
            "text": "",
            "title": "IterativeSolvers"
        },
        {
            "location": "/ecosystem/#sympy",
            "text": "",
            "title": "SymPy"
        },
        {
            "location": "/ecosystem/#onlinestats",
            "text": "",
            "title": "OnlineStats"
        },
        {
            "location": "/ecosystem/#robotlib",
            "text": "",
            "title": "Robotlib"
        },
        {
            "location": "/ecosystem/#jwas",
            "text": "",
            "title": "JWAS"
        },
        {
            "location": "/ecosystem/#quantecon",
            "text": "",
            "title": "QuantEcon"
        },
        {
            "location": "/ecosystem/#reinforce_1",
            "text": "",
            "title": "Reinforce"
        },
        {
            "location": "/ecosystem/#optim",
            "text": "",
            "title": "Optim"
        },
        {
            "location": "/ecosystem/#transformations-flow",
            "text": "",
            "title": "Transformations / Flow"
        },
        {
            "location": "/supported/",
            "text": "Series Types\n\n\nKey:\n\n\n\n\nOrange\n: the series type is natively supported by the backend.\n\n\nBlue\n: the series type is supported through series recipes.\n\n\n\n\n\n\nKeyword Arguments\n\n\n\n\nMarkers\n\n\n\n\nLine styles\n\n\n\n\nScales",
            "title": "Supported Attributes"
        },
        {
            "location": "/supported/#series-types",
            "text": "Key:   Orange : the series type is natively supported by the backend.  Blue : the series type is supported through series recipes.",
            "title": "Series Types"
        },
        {
            "location": "/supported/#keyword-arguments",
            "text": "",
            "title": "Keyword Arguments"
        },
        {
            "location": "/supported/#markers",
            "text": "",
            "title": "Markers"
        },
        {
            "location": "/supported/#line-styles",
            "text": "",
            "title": "Line styles"
        },
        {
            "location": "/supported/#scales",
            "text": "",
            "title": "Scales"
        },
        {
            "location": "/examples/pyplot/",
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\npyplot\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n->\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,\n:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\n\"lines\"\n,\nw\n=\n3\n,\npalette\n=:\ngrays\n,\nfill\n=\n0\n,\n\u03b1\n=\n0.6\n)\n\n\nscatter!\n(\ny\n,\nzcolor\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(\n:\nheat\n,\n0.8\n,\nstroke\n(\n1\n,\n:\ngreen\n)),\nms\n=\n10\n \n*\n \nabs\n(\ny\n \n-\n \n0.5\n)\n \n+\n \n4\n,\nlab\n=\n\"grad\"\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\n\"XLABEL\"\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,\n:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,\n:\ndash\n,\n0.6\n,[\n:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\n\"TITLE\"\n)\n\n\nyaxis!\n(\n\"YLABEL\"\n,\n:\nlog10\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[\n:\nblack\n \n:\norange\n],\nline\n=\n(\n:\ndot\n,\n4\n),\nmarker\n=\n([\n:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,\n:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,\n:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=:\norange\n)\n\n\n\n\n\n\n\n\nHistogram2D\n\n\nhistogram2d\n(\nrandn\n(\n10000\n),\nrandn\n(\n10000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[\n:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \n(\nfilter\n((\ns\n->\nbegin\n \n            \ns\n \nin\n \nPlots\n.\nsupported_styles\n()\n\n        \nend\n),[\n:\nsolid\n,\n:\ndash\n,\n:\ndot\n,\n:\ndashdot\n,\n:\ndashdotdot\n]))\n'\n\n\nn\n \n=\n \nlength\n(\nstyles\n)\n\n\ny\n \n=\n \ncumsum\n(\nrandn\n(\n20\n,\nn\n),\n1\n)\n\n\nplot\n(\ny\n,\nline\n=\n(\n5\n,\nstyles\n),\nlabel\n=\nmap\n(\nstring\n,\nstyles\n))\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \n(\nfilter\n((\nm\n->\nbegin\n \n            \nm\n \nin\n \nPlots\n.\nsupported_markers\n()\n\n        \nend\n),\nPlots\n.\n_shape_keys\n))\n'\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n((\nreverse\n(\nx\n))\n'\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,\n:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@layout\n([\na\n{\n0.1\nh\n};\nb\n \n[\nc\n;\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[\n:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[\n:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[\n:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\n\"this is #3\"\n,\n:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\n\"this is #5\"\n,\n16\n,\n:\nred\n,\n:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\n\"this is #10\"\n,\n:\nright\n,\n20\n,\n\"courier\"\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,\n:\norange\n),\nseries_annotations\n=\n[\n\"series\"\n,\n\"annotations\"\n,\n\"map\"\n,\n\"to\"\n,\n\"series\"\n,\ntext\n(\n\"data\"\n,\n:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,\n:\ndash\n,\n:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=:\npink\n,\nfg\n=:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nContours\n\n\nAny value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.\n\n\nx\n \n=\n \n1\n:\n0.5\n:\n20\n\n\ny\n \n=\n \n1\n:\n0.5\n:\n10\n\n\nf\n(\nx\n,\ny\n)\n \n=\n \nbegin\n \n        \n(\n3\nx\n \n+\n \ny\n \n^\n \n2\n)\n \n*\n \nabs\n(\nsin\n(\nx\n)\n \n+\n \ncos\n(\ny\n))\n\n    \nend\n\n\nX\n \n=\n \nrepmat\n(\nx\n'\n,\nlength\n(\ny\n),\n1\n)\n\n\nY\n \n=\n \nrepmat\n(\ny\n,\n1\n,\nlength\n(\nx\n))\n\n\nZ\n \n=\n \nmap\n(\nf\n,\nX\n,\nY\n)\n\n\np1\n \n=\n \ncontour\n(\nx\n,\ny\n,\nf\n,\nfill\n=\ntrue\n)\n\n\np2\n \n=\n \ncontour\n(\nx\n,\ny\n,\nZ\n)\n\n\nplot\n(\np1\n,\np2\n)\n\n\n\n\n\n\n\n\nPie\n\n\nx\n \n=\n \n[\n\"Nerds\"\n,\n\"Hackers\"\n,\n\"Scientists\"\n]\n\n\ny\n \n=\n \n[\n0.4\n,\n0.35\n,\n0.25\n]\n\n\npie\n(\nx\n,\ny\n,\ntitle\n=\n\"The Julia Community\"\n,\nl\n=\n0.5\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,\n:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nGroups and Subplots\n\n\ngroup\n \n=\n \nrand\n(\nmap\n((\ni\n->\nbegin\n \n                    \n\"group \n$\n(\ni\n)\n\"\n\n                \nend\n),\n1\n:\n4\n),\n100\n)\n\n\nplot\n(\nrand\n(\n100\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ngroup\n=\ngroup\n,\nlinetype\n=\n[\n:\nbar\n \n:\nscatter\n \n:\nsteppre\n])\n\n\n\n\n\n\n\n\nPolar Plots\n\n\n\u0398\n \n=\n \nlinspace\n(\n0\n,\n1.5\n\u03c0\n,\n100\n)\n\n\nr\n \n=\n \nabs\n(\n0.1\n \n*\n \nrandn\n(\n100\n)\n \n+\n \nsin\n(\n3\n\u0398\n))\n\n\nplot\n(\n\u0398\n,\nr\n,\nproj\n=:\npolar\n,\nm\n=\n2\n)\n\n\n\n\n\n\n\n\nHeatmap, categorical axes, and aspect_ratio\n\n\nxs\n \n=\n \n[\nstring\n(\n\"x\"\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n10\n]\n\n\nys\n \n=\n \n[\nstring\n(\n\"y\"\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n4\n]\n\n\nz\n \n=\n \nfloat\n((\n1\n:\n4\n)\n \n*\n \n(\n1\n:\n10\n)\n'\n)\n\n\nheatmap\n(\nxs\n,\nys\n,\nz\n,\naspect_ratio\n=\n1\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\n\"A\"\n \n\"B\"\n \n\"C\"\n],\ntitle_location\n=:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\nAnimation with subplots\n\n\nThe \nlayout\n macro can be used to create an animation with subplots.\n\n\nl\n \n=\n \n@layout\n([[\na\n;\nb\n]\n \nc\n])\n\n\np\n \n=\n \nplot\n(\nplot\n([\nsin\n,\ncos\n],\n1\n,\nleg\n=\nfalse\n),\nscatter\n([\natan\n,\ncos\n],\n1\n,\nleg\n=\nfalse\n),\nplot\n(\nlog\n,\n1\n,\nxlims\n=\n(\n1\n,\n10\n\u03c0\n),\nylims\n=\n(\n0\n,\n5\n),\nleg\n=\nfalse\n),\nlayout\n=\nl\n)\n\n\nanim\n \n=\n \nAnimation\n()\n\n\nfor\n \nx\n \n=\n \nlinspace\n(\n1\n,\n10\n\u03c0\n,\n100\n)\n\n    \nplot\n(\npush!\n(\np\n,\nx\n,\nFloat64\n[\nsin\n(\nx\n),\ncos\n(\nx\n),\natan\n(\nx\n),\ncos\n(\nx\n),\nlog\n(\nx\n)]))\n\n    \nframe\n(\nanim\n)\n\n\nend\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \nannotations\n, \narrow\n, \naspect_ratio\n, \nbackground_color\n, \nbackground_color_inside\n, \nbackground_color_legend\n, \nbackground_color_outside\n, \nbackground_color_subplot\n, \nbar_edges\n, \nbar_position\n, \nbar_width\n, \nbins\n, \nbottom_margin\n, \nclims\n, \ncolor_palette\n, \ncolorbar\n, \ncolorbar_title\n, \ncontours\n, \ndiscrete_values\n, \ndpi\n, \nfill_z\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nflip\n, \nforeground_color\n, \nforeground_color_axis\n, \nforeground_color_border\n, \nforeground_color_grid\n, \nforeground_color_guide\n, \nforeground_color_legend\n, \nforeground_color_subplot\n, \nforeground_color_text\n, \nforeground_color_title\n, \ngrid\n, \ngroup\n, \nguide\n, \nguidefont\n, \nhtml_output_format\n, \ninset_subplots\n, \nlabel\n, \nlayout\n, \nleft_margin\n, \nlegend\n, \nlegendfont\n, \nlevels\n, \nlims\n, \nline_z\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nlink\n, \nmargin\n, \nmarker_z\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokewidth\n, \nmatch_dimensions\n, \nnormalize\n, \norientation\n, \noverwrite_figure\n, \npolar\n, \nprimary\n, \nprojection\n, \nquiver\n, \nribbon\n, \nright_margin\n, \nrotation\n, \nscale\n, \nseries_annotations\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \nsmooth\n, \nsubplot\n, \nsubplot_index\n, \ntickfont\n, \nticks\n, \ntitle\n, \ntitle_location\n, \ntitlefont\n, \ntop_margin\n, \nweights\n, \nwindow_title\n, \nx\n, \nxdiscrete_values\n, \nxerror\n, \nxflip\n, \nxforeground_color_axis\n, \nxforeground_color_border\n, \nxforeground_color_guide\n, \nxforeground_color_text\n, \nxguide\n, \nxguidefont\n, \nxlims\n, \nxlink\n, \nxrotation\n, \nxscale\n, \nxtickfont\n, \nxticks\n, \ny\n, \nydiscrete_values\n, \nyerror\n, \nyflip\n, \nyforeground_color_axis\n, \nyforeground_color_border\n, \nyforeground_color_guide\n, \nyforeground_color_text\n, \nyguide\n, \nyguidefont\n, \nylims\n, \nylink\n, \nyrotation\n, \nyscale\n, \nytickfont\n, \nyticks\n, \nz\n, \nzdiscrete_values\n, \nzflip\n, \nzforeground_color_axis\n, \nzforeground_color_border\n, \nzforeground_color_guide\n, \nzforeground_color_text\n, \nzguide\n, \nzguidefont\n, \nzlims\n, \nzlink\n, \nzrotation\n, \nzscale\n, \nztickfont\n, \nzticks\n\n\nSupported values for linetype: \n:contour\n, \n:contour3d\n, \n:heatmap\n, \n:hexbin\n, \n:image\n, \n:path\n, \n:path3d\n, \n:pie\n, \n:scatter\n, \n:scatter3d\n, \n:shape\n, \n:steppost\n, \n:steppre\n, \n:surface\n, \n:wireframe\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:+\n, \n:auto\n, \n:circle\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:heptagon\n, \n:hexagon\n, \n:hline\n, \n:ltriangle\n, \n:none\n, \n:octagon\n, \n:pentagon\n, \n:pixel\n, \n:rect\n, \n:rtriangle\n, \n:star4\n, \n:star5\n, \n:star6\n, \n:star7\n, \n:star8\n, \n:utriangle\n, \n:vline\n, \n:x\n, \n:xcross\n\n(Automatically generated: 2017-05-31T14:45:31.255)",
            "title": "PyPlot"
        },
        {
            "location": "/examples/pyplot/#initialize",
            "text": "using   Plots  pyplot ()",
            "title": "Initialize"
        },
        {
            "location": "/examples/pyplot/#lines",
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )",
            "title": "Lines"
        },
        {
            "location": "/examples/pyplot/#parametric-plots",
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x -> begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 , : orange ))",
            "title": "Parametric plots"
        },
        {
            "location": "/examples/pyplot/#colors",
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = \"lines\" , w = 3 , palette =: grays , fill = 0 , \u03b1 = 0.6 )  scatter! ( y , zcolor = abs ( y   -   0.5 ), m = ( : heat , 0.8 , stroke ( 1 , : green )), ms = 10   *   abs ( y   -   0.5 )   +   4 , lab = \"grad\" )",
            "title": "Colors"
        },
        {
            "location": "/examples/pyplot/#global",
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( \"XLABEL\" ,( - 5 , 30 ), 0 : 2 : 20 , : flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 , : dash , 0.6 ,[ : lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( \"TITLE\" )  yaxis! ( \"YLABEL\" , : log10 )",
            "title": "Global"
        },
        {
            "location": "/examples/pyplot/#arguments",
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [ : black   : orange ], line = ( : dot , 4 ), marker = ([ : hex   : d ], 12 , 0.8 , stroke ( 3 , : gray )))",
            "title": "Arguments"
        },
        {
            "location": "/examples/pyplot/#build-plot-in-pieces",
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 , : green ))",
            "title": "Build plot in pieces"
        },
        {
            "location": "/examples/pyplot/#histogram2d",
            "text": "histogram2d ( randn ( 10000 ), randn ( 10000 ), nbins = 20 )",
            "title": "Histogram2D"
        },
        {
            "location": "/examples/pyplot/#line-types",
            "text": "linetypes   =   [ : path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )",
            "title": "Line types"
        },
        {
            "location": "/examples/pyplot/#line-styles",
            "text": "styles   =   ( filter (( s -> begin  \n             s   in   Plots . supported_styles () \n         end ),[ : solid , : dash , : dot , : dashdot , : dashdotdot ])) '  n   =   length ( styles )  y   =   cumsum ( randn ( 20 , n ), 1 )  plot ( y , line = ( 5 , styles ), label = map ( string , styles ))",
            "title": "Line styles"
        },
        {
            "location": "/examples/pyplot/#marker-types",
            "text": "markers   =   ( filter (( m -> begin  \n             m   in   Plots . supported_markers () \n         end ), Plots . _shape_keys )) '  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat (( reverse ( x )) ' , n , 1 )  scatter ( x , y , m = ( 8 , : auto ), lab = map ( string , markers ), bg =: linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))",
            "title": "Marker types"
        },
        {
            "location": "/examples/pyplot/#bar",
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))",
            "title": "Bar"
        },
        {
            "location": "/examples/pyplot/#histogram",
            "text": "histogram ( randn ( 1000 ), nbins = 20 )",
            "title": "Histogram"
        },
        {
            "location": "/examples/pyplot/#subplots",
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @layout ([ a { 0.1 h }; b   [ c ; d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [ : line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )",
            "title": "Subplots"
        },
        {
            "location": "/examples/pyplot/#adding-to-subplots",
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [ : grays   : blues   : heat   : lightrainbow ], bg_inside = [ : orange   : pink   : darkblue   : black ])",
            "title": "Adding to subplots"
        },
        {
            "location": "/examples/pyplot/#openhighlowclose",
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )",
            "title": "Open/High/Low/Close"
        },
        {
            "location": "/examples/pyplot/#annotations",
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( \"this is #3\" , : left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( \"this is #5\" , 16 , : red , : center )),( 10 , y [ 10 ], text ( \"this is #10\" , : right , 20 , \"courier\" ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 , : orange ), series_annotations = [ \"series\" , \"annotations\" , \"map\" , \"to\" , \"series\" , text ( \"data\" , : green )])",
            "title": "Annotations"
        },
        {
            "location": "/examples/pyplot/#custom-markers",
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 , : dash , : lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg =: pink , fg =: darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )",
            "title": "Custom Markers"
        },
        {
            "location": "/examples/pyplot/#contours",
            "text": "Any value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.  x   =   1 : 0.5 : 20  y   =   1 : 0.5 : 10  f ( x , y )   =   begin  \n         ( 3 x   +   y   ^   2 )   *   abs ( sin ( x )   +   cos ( y )) \n     end  X   =   repmat ( x ' , length ( y ), 1 )  Y   =   repmat ( y , 1 , length ( x ))  Z   =   map ( f , X , Y )  p1   =   contour ( x , y , f , fill = true )  p2   =   contour ( x , y , Z )  plot ( p1 , p2 )",
            "title": "Contours"
        },
        {
            "location": "/examples/pyplot/#pie",
            "text": "x   =   [ \"Nerds\" , \"Hackers\" , \"Scientists\" ]  y   =   [ 0.4 , 0.35 , 0.25 ]  pie ( x , y , title = \"The Julia Community\" , l = 0.5 )",
            "title": "Pie"
        },
        {
            "location": "/examples/pyplot/#3d",
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 , : blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )",
            "title": "3D"
        },
        {
            "location": "/examples/pyplot/#groups-and-subplots",
            "text": "group   =   rand ( map (( i -> begin  \n                     \"group  $ ( i ) \" \n                 end ), 1 : 4 ), 100 )  plot ( rand ( 100 ), layout = @layout ([ a   b ; c ]), group = group , linetype = [ : bar   : scatter   : steppre ])",
            "title": "Groups and Subplots"
        },
        {
            "location": "/examples/pyplot/#polar-plots",
            "text": "\u0398   =   linspace ( 0 , 1.5 \u03c0 , 100 )  r   =   abs ( 0.1   *   randn ( 100 )   +   sin ( 3 \u0398 ))  plot ( \u0398 , r , proj =: polar , m = 2 )",
            "title": "Polar Plots"
        },
        {
            "location": "/examples/pyplot/#heatmap-categorical-axes-and-aspect_ratio",
            "text": "xs   =   [ string ( \"x\" , i )   for   i   =   1 : 10 ]  ys   =   [ string ( \"y\" , i )   for   i   =   1 : 4 ]  z   =   float (( 1 : 4 )   *   ( 1 : 10 ) ' )  heatmap ( xs , ys , z , aspect_ratio = 1 )",
            "title": "Heatmap, categorical axes, and aspect_ratio"
        },
        {
            "location": "/examples/pyplot/#layouts-margins-label-rotation-title-location",
            "text": "plot ( rand ( 100 , 6 ), layout = @layout ([ a   b ; c ]), title = [ \"A\"   \"B\"   \"C\" ], title_location =: left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )",
            "title": "Layouts, margins, label rotation, title location"
        },
        {
            "location": "/examples/pyplot/#animation-with-subplots",
            "text": "The  layout  macro can be used to create an animation with subplots.  l   =   @layout ([[ a ; b ]   c ])  p   =   plot ( plot ([ sin , cos ], 1 , leg = false ), scatter ([ atan , cos ], 1 , leg = false ), plot ( log , 1 , xlims = ( 1 , 10 \u03c0 ), ylims = ( 0 , 5 ), leg = false ), layout = l )  anim   =   Animation ()  for   x   =   linspace ( 1 , 10 \u03c0 , 100 ) \n     plot ( push! ( p , x , Float64 [ sin ( x ), cos ( x ), atan ( x ), cos ( x ), log ( x )])) \n     frame ( anim )  end     Supported arguments:  annotations ,  arrow ,  aspect_ratio ,  background_color ,  background_color_inside ,  background_color_legend ,  background_color_outside ,  background_color_subplot ,  bar_edges ,  bar_position ,  bar_width ,  bins ,  bottom_margin ,  clims ,  color_palette ,  colorbar ,  colorbar_title ,  contours ,  discrete_values ,  dpi ,  fill_z ,  fillalpha ,  fillcolor ,  fillrange ,  flip ,  foreground_color ,  foreground_color_axis ,  foreground_color_border ,  foreground_color_grid ,  foreground_color_guide ,  foreground_color_legend ,  foreground_color_subplot ,  foreground_color_text ,  foreground_color_title ,  grid ,  group ,  guide ,  guidefont ,  html_output_format ,  inset_subplots ,  label ,  layout ,  left_margin ,  legend ,  legendfont ,  levels ,  lims ,  line_z ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  link ,  margin ,  marker_z ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokewidth ,  match_dimensions ,  normalize ,  orientation ,  overwrite_figure ,  polar ,  primary ,  projection ,  quiver ,  ribbon ,  right_margin ,  rotation ,  scale ,  series_annotations ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  smooth ,  subplot ,  subplot_index ,  tickfont ,  ticks ,  title ,  title_location ,  titlefont ,  top_margin ,  weights ,  window_title ,  x ,  xdiscrete_values ,  xerror ,  xflip ,  xforeground_color_axis ,  xforeground_color_border ,  xforeground_color_guide ,  xforeground_color_text ,  xguide ,  xguidefont ,  xlims ,  xlink ,  xrotation ,  xscale ,  xtickfont ,  xticks ,  y ,  ydiscrete_values ,  yerror ,  yflip ,  yforeground_color_axis ,  yforeground_color_border ,  yforeground_color_guide ,  yforeground_color_text ,  yguide ,  yguidefont ,  ylims ,  ylink ,  yrotation ,  yscale ,  ytickfont ,  yticks ,  z ,  zdiscrete_values ,  zflip ,  zforeground_color_axis ,  zforeground_color_border ,  zforeground_color_guide ,  zforeground_color_text ,  zguide ,  zguidefont ,  zlims ,  zlink ,  zrotation ,  zscale ,  ztickfont ,  zticks  Supported values for linetype:  :contour ,  :contour3d ,  :heatmap ,  :hexbin ,  :image ,  :path ,  :path3d ,  :pie ,  :scatter ,  :scatter3d ,  :shape ,  :steppost ,  :steppre ,  :surface ,  :wireframe  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dot ,  :solid  Supported values for marker:  :+ ,  :auto ,  :circle ,  :cross ,  :diamond ,  :dtriangle ,  :heptagon ,  :hexagon ,  :hline ,  :ltriangle ,  :none ,  :octagon ,  :pentagon ,  :pixel ,  :rect ,  :rtriangle ,  :star4 ,  :star5 ,  :star6 ,  :star7 ,  :star8 ,  :utriangle ,  :vline ,  :x ,  :xcross \n(Automatically generated: 2017-05-31T14:45:31.255)",
            "title": "Animation with subplots"
        },
        {
            "location": "/examples/gr/",
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\ngr\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n->\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,\n:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\n\"lines\"\n,\nw\n=\n3\n,\npalette\n=:\ngrays\n,\nfill\n=\n0\n,\n\u03b1\n=\n0.6\n)\n\n\nscatter!\n(\ny\n,\nzcolor\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(\n:\nheat\n,\n0.8\n,\nstroke\n(\n1\n,\n:\ngreen\n)),\nms\n=\n10\n \n*\n \nabs\n(\ny\n \n-\n \n0.5\n)\n \n+\n \n4\n,\nlab\n=\n\"grad\"\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\n\"XLABEL\"\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,\n:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,\n:\ndash\n,\n0.6\n,[\n:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\n\"TITLE\"\n)\n\n\nyaxis!\n(\n\"YLABEL\"\n,\n:\nlog10\n)\n\n\n\n\n\n\n\n\nImages\n\n\nPlot an image.  y-axis is set to flipped\n\n\nimport\n \nImages\n\n\nimg\n \n=\n \nImages\n.\nload\n(\nPkg\n.\ndir\n(\n\"PlotReferenceImages\"\n,\n\"Plots\"\n,\n\"pyplot\"\n,\n\"0.7.0\"\n,\n\"ref1.png\"\n))\n\n\nplot\n(\nimg\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[\n:\nblack\n \n:\norange\n],\nline\n=\n(\n:\ndot\n,\n4\n),\nmarker\n=\n([\n:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,\n:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,\n:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=:\norange\n)\n\n\n\n\n\n\n\n\nHistogram2D\n\n\nhistogram2d\n(\nrandn\n(\n10000\n),\nrandn\n(\n10000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[\n:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \n(\nfilter\n((\ns\n->\nbegin\n \n            \ns\n \nin\n \nPlots\n.\nsupported_styles\n()\n\n        \nend\n),[\n:\nsolid\n,\n:\ndash\n,\n:\ndot\n,\n:\ndashdot\n,\n:\ndashdotdot\n]))\n'\n\n\nn\n \n=\n \nlength\n(\nstyles\n)\n\n\ny\n \n=\n \ncumsum\n(\nrandn\n(\n20\n,\nn\n),\n1\n)\n\n\nplot\n(\ny\n,\nline\n=\n(\n5\n,\nstyles\n),\nlabel\n=\nmap\n(\nstring\n,\nstyles\n))\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \n(\nfilter\n((\nm\n->\nbegin\n \n            \nm\n \nin\n \nPlots\n.\nsupported_markers\n()\n\n        \nend\n),\nPlots\n.\n_shape_keys\n))\n'\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n((\nreverse\n(\nx\n))\n'\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,\n:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@layout\n([\na\n{\n0.1\nh\n};\nb\n \n[\nc\n;\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[\n:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[\n:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[\n:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\n\"this is #3\"\n,\n:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\n\"this is #5\"\n,\n16\n,\n:\nred\n,\n:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\n\"this is #10\"\n,\n:\nright\n,\n20\n,\n\"courier\"\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,\n:\norange\n),\nseries_annotations\n=\n[\n\"series\"\n,\n\"annotations\"\n,\n\"map\"\n,\n\"to\"\n,\n\"series\"\n,\ntext\n(\n\"data\"\n,\n:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,\n:\ndash\n,\n:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=:\npink\n,\nfg\n=:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nContours\n\n\nAny value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.\n\n\nx\n \n=\n \n1\n:\n0.5\n:\n20\n\n\ny\n \n=\n \n1\n:\n0.5\n:\n10\n\n\nf\n(\nx\n,\ny\n)\n \n=\n \nbegin\n \n        \n(\n3\nx\n \n+\n \ny\n \n^\n \n2\n)\n \n*\n \nabs\n(\nsin\n(\nx\n)\n \n+\n \ncos\n(\ny\n))\n\n    \nend\n\n\nX\n \n=\n \nrepmat\n(\nx\n'\n,\nlength\n(\ny\n),\n1\n)\n\n\nY\n \n=\n \nrepmat\n(\ny\n,\n1\n,\nlength\n(\nx\n))\n\n\nZ\n \n=\n \nmap\n(\nf\n,\nX\n,\nY\n)\n\n\np1\n \n=\n \ncontour\n(\nx\n,\ny\n,\nf\n,\nfill\n=\ntrue\n)\n\n\np2\n \n=\n \ncontour\n(\nx\n,\ny\n,\nZ\n)\n\n\nplot\n(\np1\n,\np2\n)\n\n\n\n\n\n\n\n\nPie\n\n\nx\n \n=\n \n[\n\"Nerds\"\n,\n\"Hackers\"\n,\n\"Scientists\"\n]\n\n\ny\n \n=\n \n[\n0.4\n,\n0.35\n,\n0.25\n]\n\n\npie\n(\nx\n,\ny\n,\ntitle\n=\n\"The Julia Community\"\n,\nl\n=\n0.5\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,\n:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nGroups and Subplots\n\n\ngroup\n \n=\n \nrand\n(\nmap\n((\ni\n->\nbegin\n \n                    \n\"group \n$\n(\ni\n)\n\"\n\n                \nend\n),\n1\n:\n4\n),\n100\n)\n\n\nplot\n(\nrand\n(\n100\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ngroup\n=\ngroup\n,\nlinetype\n=\n[\n:\nbar\n \n:\nscatter\n \n:\nsteppre\n])\n\n\n\n\n\n\n\n\nPolar Plots\n\n\n\u0398\n \n=\n \nlinspace\n(\n0\n,\n1.5\n\u03c0\n,\n100\n)\n\n\nr\n \n=\n \nabs\n(\n0.1\n \n*\n \nrandn\n(\n100\n)\n \n+\n \nsin\n(\n3\n\u0398\n))\n\n\nplot\n(\n\u0398\n,\nr\n,\nproj\n=:\npolar\n,\nm\n=\n2\n)\n\n\n\n\n\n\n\n\nHeatmap, categorical axes, and aspect_ratio\n\n\nxs\n \n=\n \n[\nstring\n(\n\"x\"\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n10\n]\n\n\nys\n \n=\n \n[\nstring\n(\n\"y\"\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n4\n]\n\n\nz\n \n=\n \nfloat\n((\n1\n:\n4\n)\n \n*\n \n(\n1\n:\n10\n)\n'\n)\n\n\nheatmap\n(\nxs\n,\nys\n,\nz\n,\naspect_ratio\n=\n1\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\n\"A\"\n \n\"B\"\n \n\"C\"\n],\ntitle_location\n=:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\nAnimation with subplots\n\n\nThe \nlayout\n macro can be used to create an animation with subplots.\n\n\nl\n \n=\n \n@layout\n([[\na\n;\nb\n]\n \nc\n])\n\n\np\n \n=\n \nplot\n(\nplot\n([\nsin\n,\ncos\n],\n1\n,\nleg\n=\nfalse\n),\nscatter\n([\natan\n,\ncos\n],\n1\n,\nleg\n=\nfalse\n),\nplot\n(\nlog\n,\n1\n,\nxlims\n=\n(\n1\n,\n10\n\u03c0\n),\nylims\n=\n(\n0\n,\n5\n),\nleg\n=\nfalse\n),\nlayout\n=\nl\n)\n\n\nanim\n \n=\n \nAnimation\n()\n\n\nfor\n \nx\n \n=\n \nlinspace\n(\n1\n,\n10\n\u03c0\n,\n100\n)\n\n    \nplot\n(\npush!\n(\np\n,\nx\n,\nFloat64\n[\nsin\n(\nx\n),\ncos\n(\nx\n),\natan\n(\nx\n),\ncos\n(\nx\n),\nlog\n(\nx\n)]))\n\n    \nframe\n(\nanim\n)\n\n\nend\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \nannotations\n, \narrow\n, \naspect_ratio\n, \nbackground_color\n, \nbackground_color_inside\n, \nbackground_color_legend\n, \nbackground_color_outside\n, \nbackground_color_subplot\n, \nbar_width\n, \nbins\n, \nbottom_margin\n, \ncolor_palette\n, \ncolorbar\n, \ndiscrete_values\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nflip\n, \nforeground_color\n, \nforeground_color_axis\n, \nforeground_color_border\n, \nforeground_color_grid\n, \nforeground_color_legend\n, \nforeground_color_subplot\n, \nforeground_color_text\n, \ngrid\n, \ngroup\n, \nguide\n, \nguidefont\n, \nhtml_output_format\n, \ninset_subplots\n, \nlabel\n, \nlayout\n, \nleft_margin\n, \nlegend\n, \nlegendfont\n, \nlevels\n, \nlims\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nlink\n, \nmargin\n, \nmarker_z\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokewidth\n, \nmatch_dimensions\n, \nnormalize\n, \norientation\n, \noverwrite_figure\n, \npolar\n, \nprimary\n, \nprojection\n, \nquiver\n, \nribbon\n, \nright_margin\n, \nscale\n, \nseries_annotations\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \nsmooth\n, \nsubplot\n, \nsubplot_index\n, \ntickfont\n, \nticks\n, \ntitle\n, \ntop_margin\n, \nweights\n, \nwindow_title\n, \nx\n, \nxdiscrete_values\n, \nxerror\n, \nxflip\n, \nxforeground_color_axis\n, \nxforeground_color_border\n, \nxforeground_color_text\n, \nxguide\n, \nxguidefont\n, \nxlims\n, \nxlink\n, \nxscale\n, \nxtickfont\n, \nxticks\n, \ny\n, \nydiscrete_values\n, \nyerror\n, \nyflip\n, \nyforeground_color_axis\n, \nyforeground_color_border\n, \nyforeground_color_text\n, \nyguide\n, \nyguidefont\n, \nylims\n, \nylink\n, \nyscale\n, \nytickfont\n, \nyticks\n, \nz\n, \nzdiscrete_values\n, \nzflip\n, \nzforeground_color_axis\n, \nzforeground_color_border\n, \nzforeground_color_text\n, \nzguide\n, \nzguidefont\n, \nzlims\n, \nzlink\n, \nzscale\n, \nztickfont\n, \nzticks\n\n\nSupported values for linetype: \n:contour\n, \n:heatmap\n, \n:image\n, \n:path\n, \n:path3d\n, \n:pie\n, \n:scatter\n, \n:scatter3d\n, \n:shape\n, \n:surface\n, \n:wireframe\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dashdotdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:+\n, \n:auto\n, \n:circle\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:heptagon\n, \n:hexagon\n, \n:hline\n, \n:ltriangle\n, \n:none\n, \n:octagon\n, \n:pentagon\n, \n:rect\n, \n:rtriangle\n, \n:star4\n, \n:star5\n, \n:star6\n, \n:star7\n, \n:star8\n, \n:utriangle\n, \n:vline\n, \n:x\n, \n:xcross\n\n(Automatically generated: 2017-05-31T14:41:44.273)",
            "title": "GR"
        },
        {
            "location": "/examples/gr/#initialize",
            "text": "using   Plots  gr ()",
            "title": "Initialize"
        },
        {
            "location": "/examples/gr/#lines",
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )",
            "title": "Lines"
        },
        {
            "location": "/examples/gr/#parametric-plots",
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x -> begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 , : orange ))",
            "title": "Parametric plots"
        },
        {
            "location": "/examples/gr/#colors",
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = \"lines\" , w = 3 , palette =: grays , fill = 0 , \u03b1 = 0.6 )  scatter! ( y , zcolor = abs ( y   -   0.5 ), m = ( : heat , 0.8 , stroke ( 1 , : green )), ms = 10   *   abs ( y   -   0.5 )   +   4 , lab = \"grad\" )",
            "title": "Colors"
        },
        {
            "location": "/examples/gr/#global",
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( \"XLABEL\" ,( - 5 , 30 ), 0 : 2 : 20 , : flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 , : dash , 0.6 ,[ : lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( \"TITLE\" )  yaxis! ( \"YLABEL\" , : log10 )",
            "title": "Global"
        },
        {
            "location": "/examples/gr/#images",
            "text": "Plot an image.  y-axis is set to flipped  import   Images  img   =   Images . load ( Pkg . dir ( \"PlotReferenceImages\" , \"Plots\" , \"pyplot\" , \"0.7.0\" , \"ref1.png\" ))  plot ( img )",
            "title": "Images"
        },
        {
            "location": "/examples/gr/#arguments",
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [ : black   : orange ], line = ( : dot , 4 ), marker = ([ : hex   : d ], 12 , 0.8 , stroke ( 3 , : gray )))",
            "title": "Arguments"
        },
        {
            "location": "/examples/gr/#build-plot-in-pieces",
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 , : green ))",
            "title": "Build plot in pieces"
        },
        {
            "location": "/examples/gr/#histogram2d",
            "text": "histogram2d ( randn ( 10000 ), randn ( 10000 ), nbins = 20 )",
            "title": "Histogram2D"
        },
        {
            "location": "/examples/gr/#line-types",
            "text": "linetypes   =   [ : path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )",
            "title": "Line types"
        },
        {
            "location": "/examples/gr/#line-styles",
            "text": "styles   =   ( filter (( s -> begin  \n             s   in   Plots . supported_styles () \n         end ),[ : solid , : dash , : dot , : dashdot , : dashdotdot ])) '  n   =   length ( styles )  y   =   cumsum ( randn ( 20 , n ), 1 )  plot ( y , line = ( 5 , styles ), label = map ( string , styles ))",
            "title": "Line styles"
        },
        {
            "location": "/examples/gr/#marker-types",
            "text": "markers   =   ( filter (( m -> begin  \n             m   in   Plots . supported_markers () \n         end ), Plots . _shape_keys )) '  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat (( reverse ( x )) ' , n , 1 )  scatter ( x , y , m = ( 8 , : auto ), lab = map ( string , markers ), bg =: linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))",
            "title": "Marker types"
        },
        {
            "location": "/examples/gr/#bar",
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))",
            "title": "Bar"
        },
        {
            "location": "/examples/gr/#histogram",
            "text": "histogram ( randn ( 1000 ), nbins = 20 )",
            "title": "Histogram"
        },
        {
            "location": "/examples/gr/#subplots",
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @layout ([ a { 0.1 h }; b   [ c ; d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [ : line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )",
            "title": "Subplots"
        },
        {
            "location": "/examples/gr/#adding-to-subplots",
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [ : grays   : blues   : heat   : lightrainbow ], bg_inside = [ : orange   : pink   : darkblue   : black ])",
            "title": "Adding to subplots"
        },
        {
            "location": "/examples/gr/#openhighlowclose",
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )",
            "title": "Open/High/Low/Close"
        },
        {
            "location": "/examples/gr/#annotations",
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( \"this is #3\" , : left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( \"this is #5\" , 16 , : red , : center )),( 10 , y [ 10 ], text ( \"this is #10\" , : right , 20 , \"courier\" ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 , : orange ), series_annotations = [ \"series\" , \"annotations\" , \"map\" , \"to\" , \"series\" , text ( \"data\" , : green )])",
            "title": "Annotations"
        },
        {
            "location": "/examples/gr/#custom-markers",
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 , : dash , : lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg =: pink , fg =: darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )",
            "title": "Custom Markers"
        },
        {
            "location": "/examples/gr/#contours",
            "text": "Any value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.  x   =   1 : 0.5 : 20  y   =   1 : 0.5 : 10  f ( x , y )   =   begin  \n         ( 3 x   +   y   ^   2 )   *   abs ( sin ( x )   +   cos ( y )) \n     end  X   =   repmat ( x ' , length ( y ), 1 )  Y   =   repmat ( y , 1 , length ( x ))  Z   =   map ( f , X , Y )  p1   =   contour ( x , y , f , fill = true )  p2   =   contour ( x , y , Z )  plot ( p1 , p2 )",
            "title": "Contours"
        },
        {
            "location": "/examples/gr/#pie",
            "text": "x   =   [ \"Nerds\" , \"Hackers\" , \"Scientists\" ]  y   =   [ 0.4 , 0.35 , 0.25 ]  pie ( x , y , title = \"The Julia Community\" , l = 0.5 )",
            "title": "Pie"
        },
        {
            "location": "/examples/gr/#3d",
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 , : blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )",
            "title": "3D"
        },
        {
            "location": "/examples/gr/#groups-and-subplots",
            "text": "group   =   rand ( map (( i -> begin  \n                     \"group  $ ( i ) \" \n                 end ), 1 : 4 ), 100 )  plot ( rand ( 100 ), layout = @layout ([ a   b ; c ]), group = group , linetype = [ : bar   : scatter   : steppre ])",
            "title": "Groups and Subplots"
        },
        {
            "location": "/examples/gr/#polar-plots",
            "text": "\u0398   =   linspace ( 0 , 1.5 \u03c0 , 100 )  r   =   abs ( 0.1   *   randn ( 100 )   +   sin ( 3 \u0398 ))  plot ( \u0398 , r , proj =: polar , m = 2 )",
            "title": "Polar Plots"
        },
        {
            "location": "/examples/gr/#heatmap-categorical-axes-and-aspect_ratio",
            "text": "xs   =   [ string ( \"x\" , i )   for   i   =   1 : 10 ]  ys   =   [ string ( \"y\" , i )   for   i   =   1 : 4 ]  z   =   float (( 1 : 4 )   *   ( 1 : 10 ) ' )  heatmap ( xs , ys , z , aspect_ratio = 1 )",
            "title": "Heatmap, categorical axes, and aspect_ratio"
        },
        {
            "location": "/examples/gr/#layouts-margins-label-rotation-title-location",
            "text": "plot ( rand ( 100 , 6 ), layout = @layout ([ a   b ; c ]), title = [ \"A\"   \"B\"   \"C\" ], title_location =: left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )",
            "title": "Layouts, margins, label rotation, title location"
        },
        {
            "location": "/examples/gr/#animation-with-subplots",
            "text": "The  layout  macro can be used to create an animation with subplots.  l   =   @layout ([[ a ; b ]   c ])  p   =   plot ( plot ([ sin , cos ], 1 , leg = false ), scatter ([ atan , cos ], 1 , leg = false ), plot ( log , 1 , xlims = ( 1 , 10 \u03c0 ), ylims = ( 0 , 5 ), leg = false ), layout = l )  anim   =   Animation ()  for   x   =   linspace ( 1 , 10 \u03c0 , 100 ) \n     plot ( push! ( p , x , Float64 [ sin ( x ), cos ( x ), atan ( x ), cos ( x ), log ( x )])) \n     frame ( anim )  end     Supported arguments:  annotations ,  arrow ,  aspect_ratio ,  background_color ,  background_color_inside ,  background_color_legend ,  background_color_outside ,  background_color_subplot ,  bar_width ,  bins ,  bottom_margin ,  color_palette ,  colorbar ,  discrete_values ,  fillalpha ,  fillcolor ,  fillrange ,  flip ,  foreground_color ,  foreground_color_axis ,  foreground_color_border ,  foreground_color_grid ,  foreground_color_legend ,  foreground_color_subplot ,  foreground_color_text ,  grid ,  group ,  guide ,  guidefont ,  html_output_format ,  inset_subplots ,  label ,  layout ,  left_margin ,  legend ,  legendfont ,  levels ,  lims ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  link ,  margin ,  marker_z ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokewidth ,  match_dimensions ,  normalize ,  orientation ,  overwrite_figure ,  polar ,  primary ,  projection ,  quiver ,  ribbon ,  right_margin ,  scale ,  series_annotations ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  smooth ,  subplot ,  subplot_index ,  tickfont ,  ticks ,  title ,  top_margin ,  weights ,  window_title ,  x ,  xdiscrete_values ,  xerror ,  xflip ,  xforeground_color_axis ,  xforeground_color_border ,  xforeground_color_text ,  xguide ,  xguidefont ,  xlims ,  xlink ,  xscale ,  xtickfont ,  xticks ,  y ,  ydiscrete_values ,  yerror ,  yflip ,  yforeground_color_axis ,  yforeground_color_border ,  yforeground_color_text ,  yguide ,  yguidefont ,  ylims ,  ylink ,  yscale ,  ytickfont ,  yticks ,  z ,  zdiscrete_values ,  zflip ,  zforeground_color_axis ,  zforeground_color_border ,  zforeground_color_text ,  zguide ,  zguidefont ,  zlims ,  zlink ,  zscale ,  ztickfont ,  zticks  Supported values for linetype:  :contour ,  :heatmap ,  :image ,  :path ,  :path3d ,  :pie ,  :scatter ,  :scatter3d ,  :shape ,  :surface ,  :wireframe  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dashdotdot ,  :dot ,  :solid  Supported values for marker:  :+ ,  :auto ,  :circle ,  :cross ,  :diamond ,  :dtriangle ,  :heptagon ,  :hexagon ,  :hline ,  :ltriangle ,  :none ,  :octagon ,  :pentagon ,  :rect ,  :rtriangle ,  :star4 ,  :star5 ,  :star6 ,  :star7 ,  :star8 ,  :utriangle ,  :vline ,  :x ,  :xcross \n(Automatically generated: 2017-05-31T14:41:44.273)",
            "title": "Animation with subplots"
        },
        {
            "location": "/examples/plotlyjs/",
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\nplotlyjs\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n->\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,\n:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\n\"lines\"\n,\nw\n=\n3\n,\npalette\n=:\ngrays\n,\nfill\n=\n0\n,\n\u03b1\n=\n0.6\n)\n\n\nscatter!\n(\ny\n,\nzcolor\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(\n:\nheat\n,\n0.8\n,\nstroke\n(\n1\n,\n:\ngreen\n)),\nms\n=\n10\n \n*\n \nabs\n(\ny\n \n-\n \n0.5\n)\n \n+\n \n4\n,\nlab\n=\n\"grad\"\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\n\"XLABEL\"\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,\n:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,\n:\ndash\n,\n0.6\n,[\n:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\n\"TITLE\"\n)\n\n\nyaxis!\n(\n\"YLABEL\"\n,\n:\nlog10\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[\n:\nblack\n \n:\norange\n],\nline\n=\n(\n:\ndot\n,\n4\n),\nmarker\n=\n([\n:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,\n:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,\n:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=:\norange\n)\n\n\n\n\n\n\n\n\nHistogram2D\n\n\nhistogram2d\n(\nrandn\n(\n10000\n),\nrandn\n(\n10000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[\n:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \n(\nfilter\n((\ns\n->\nbegin\n \n            \ns\n \nin\n \nPlots\n.\nsupported_styles\n()\n\n        \nend\n),[\n:\nsolid\n,\n:\ndash\n,\n:\ndot\n,\n:\ndashdot\n,\n:\ndashdotdot\n]))\n'\n\n\nn\n \n=\n \nlength\n(\nstyles\n)\n\n\ny\n \n=\n \ncumsum\n(\nrandn\n(\n20\n,\nn\n),\n1\n)\n\n\nplot\n(\ny\n,\nline\n=\n(\n5\n,\nstyles\n),\nlabel\n=\nmap\n(\nstring\n,\nstyles\n))\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \n(\nfilter\n((\nm\n->\nbegin\n \n            \nm\n \nin\n \nPlots\n.\nsupported_markers\n()\n\n        \nend\n),\nPlots\n.\n_shape_keys\n))\n'\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n((\nreverse\n(\nx\n))\n'\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,\n:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@layout\n([\na\n{\n0.1\nh\n};\nb\n \n[\nc\n;\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[\n:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[\n:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[\n:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\n\"this is #3\"\n,\n:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\n\"this is #5\"\n,\n16\n,\n:\nred\n,\n:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\n\"this is #10\"\n,\n:\nright\n,\n20\n,\n\"courier\"\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,\n:\norange\n),\nseries_annotations\n=\n[\n\"series\"\n,\n\"annotations\"\n,\n\"map\"\n,\n\"to\"\n,\n\"series\"\n,\ntext\n(\n\"data\"\n,\n:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,\n:\ndash\n,\n:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=:\npink\n,\nfg\n=:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nContours\n\n\nAny value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.\n\n\nx\n \n=\n \n1\n:\n0.5\n:\n20\n\n\ny\n \n=\n \n1\n:\n0.5\n:\n10\n\n\nf\n(\nx\n,\ny\n)\n \n=\n \nbegin\n \n        \n(\n3\nx\n \n+\n \ny\n \n^\n \n2\n)\n \n*\n \nabs\n(\nsin\n(\nx\n)\n \n+\n \ncos\n(\ny\n))\n\n    \nend\n\n\nX\n \n=\n \nrepmat\n(\nx\n'\n,\nlength\n(\ny\n),\n1\n)\n\n\nY\n \n=\n \nrepmat\n(\ny\n,\n1\n,\nlength\n(\nx\n))\n\n\nZ\n \n=\n \nmap\n(\nf\n,\nX\n,\nY\n)\n\n\np1\n \n=\n \ncontour\n(\nx\n,\ny\n,\nf\n,\nfill\n=\ntrue\n)\n\n\np2\n \n=\n \ncontour\n(\nx\n,\ny\n,\nZ\n)\n\n\nplot\n(\np1\n,\np2\n)\n\n\n\n\n\n\n\n\nPie\n\n\nx\n \n=\n \n[\n\"Nerds\"\n,\n\"Hackers\"\n,\n\"Scientists\"\n]\n\n\ny\n \n=\n \n[\n0.4\n,\n0.35\n,\n0.25\n]\n\n\npie\n(\nx\n,\ny\n,\ntitle\n=\n\"The Julia Community\"\n,\nl\n=\n0.5\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,\n:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nGroups and Subplots\n\n\ngroup\n \n=\n \nrand\n(\nmap\n((\ni\n->\nbegin\n \n                    \n\"group \n$\n(\ni\n)\n\"\n\n                \nend\n),\n1\n:\n4\n),\n100\n)\n\n\nplot\n(\nrand\n(\n100\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ngroup\n=\ngroup\n,\nlinetype\n=\n[\n:\nbar\n \n:\nscatter\n \n:\nsteppre\n])\n\n\n\n\n\n\n\n\nHeatmap, categorical axes, and aspect_ratio\n\n\nxs\n \n=\n \n[\nstring\n(\n\"x\"\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n10\n]\n\n\nys\n \n=\n \n[\nstring\n(\n\"y\"\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n4\n]\n\n\nz\n \n=\n \nfloat\n((\n1\n:\n4\n)\n \n*\n \n(\n1\n:\n10\n)\n'\n)\n\n\nheatmap\n(\nxs\n,\nys\n,\nz\n,\naspect_ratio\n=\n1\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\n\"A\"\n \n\"B\"\n \n\"C\"\n],\ntitle_location\n=:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \nannotations\n, \naspect_ratio\n, \nbackground_color\n, \nbackground_color_inside\n, \nbackground_color_legend\n, \nbackground_color_outside\n, \nbackground_color_subplot\n, \nbar_width\n, \nbins\n, \nbottom_margin\n, \nclims\n, \ncolor_palette\n, \ncolorbar\n, \ncolorbar_title\n, \ndiscrete_values\n, \nfill_z\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nflip\n, \nforeground_color\n, \nforeground_color_border\n, \nforeground_color_guide\n, \nforeground_color_legend\n, \nforeground_color_subplot\n, \nforeground_color_text\n, \nforeground_color_title\n, \ngrid\n, \ngroup\n, \nguide\n, \nguidefont\n, \nhover\n, \nhtml_output_format\n, \ninset_subplots\n, \nlabel\n, \nlayout\n, \nleft_margin\n, \nlegend\n, \nlegendfont\n, \nlevels\n, \nlims\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nlink\n, \nmargin\n, \nmarker_z\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokestyle\n, \nmarkerstrokewidth\n, \nnormalize\n, \norientation\n, \npolar\n, \nprimary\n, \nprojection\n, \nquiver\n, \nribbon\n, \nright_margin\n, \nrotation\n, \nscale\n, \nseries_annotations\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \nsmooth\n, \nsubplot\n, \nsubplot_index\n, \ntickfont\n, \nticks\n, \ntitle\n, \ntitle_location\n, \ntitlefont\n, \ntop_margin\n, \nweights\n, \nwindow_title\n, \nx\n, \nxdiscrete_values\n, \nxerror\n, \nxflip\n, \nxforeground_color_border\n, \nxforeground_color_guide\n, \nxforeground_color_text\n, \nxguide\n, \nxguidefont\n, \nxlims\n, \nxlink\n, \nxrotation\n, \nxscale\n, \nxtickfont\n, \nxticks\n, \ny\n, \nydiscrete_values\n, \nyerror\n, \nyflip\n, \nyforeground_color_border\n, \nyforeground_color_guide\n, \nyforeground_color_text\n, \nyguide\n, \nyguidefont\n, \nylims\n, \nylink\n, \nyrotation\n, \nyscale\n, \nytickfont\n, \nyticks\n, \nz\n, \nzdiscrete_values\n, \nzflip\n, \nzforeground_color_border\n, \nzforeground_color_guide\n, \nzforeground_color_text\n, \nzguide\n, \nzguidefont\n, \nzlims\n, \nzlink\n, \nzrotation\n, \nzscale\n, \nztickfont\n, \nzticks\n\n\nSupported values for linetype: \n:bar\n, \n:contour\n, \n:heatmap\n, \n:path\n, \n:path3d\n, \n:pie\n, \n:scatter\n, \n:scatter3d\n, \n:scattergl\n, \n:shape\n, \n:surface\n, \n:wireframe\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:auto\n, \n:circle\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:hexagon\n, \n:hline\n, \n:none\n, \n:octagon\n, \n:pentagon\n, \n:rect\n, \n:utriangle\n, \n:vline\n, \n:xcross\n\n(Automatically generated: 2017-05-31T15:24:42.231)",
            "title": "PlotlyJS"
        },
        {
            "location": "/examples/plotlyjs/#initialize",
            "text": "using   Plots  plotlyjs ()",
            "title": "Initialize"
        },
        {
            "location": "/examples/plotlyjs/#lines",
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )",
            "title": "Lines"
        },
        {
            "location": "/examples/plotlyjs/#parametric-plots",
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x -> begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 , : orange ))",
            "title": "Parametric plots"
        },
        {
            "location": "/examples/plotlyjs/#colors",
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = \"lines\" , w = 3 , palette =: grays , fill = 0 , \u03b1 = 0.6 )  scatter! ( y , zcolor = abs ( y   -   0.5 ), m = ( : heat , 0.8 , stroke ( 1 , : green )), ms = 10   *   abs ( y   -   0.5 )   +   4 , lab = \"grad\" )",
            "title": "Colors"
        },
        {
            "location": "/examples/plotlyjs/#global",
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( \"XLABEL\" ,( - 5 , 30 ), 0 : 2 : 20 , : flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 , : dash , 0.6 ,[ : lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( \"TITLE\" )  yaxis! ( \"YLABEL\" , : log10 )",
            "title": "Global"
        },
        {
            "location": "/examples/plotlyjs/#arguments",
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [ : black   : orange ], line = ( : dot , 4 ), marker = ([ : hex   : d ], 12 , 0.8 , stroke ( 3 , : gray )))",
            "title": "Arguments"
        },
        {
            "location": "/examples/plotlyjs/#build-plot-in-pieces",
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 , : green ))",
            "title": "Build plot in pieces"
        },
        {
            "location": "/examples/plotlyjs/#histogram2d",
            "text": "histogram2d ( randn ( 10000 ), randn ( 10000 ), nbins = 20 )",
            "title": "Histogram2D"
        },
        {
            "location": "/examples/plotlyjs/#line-types",
            "text": "linetypes   =   [ : path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )",
            "title": "Line types"
        },
        {
            "location": "/examples/plotlyjs/#line-styles",
            "text": "styles   =   ( filter (( s -> begin  \n             s   in   Plots . supported_styles () \n         end ),[ : solid , : dash , : dot , : dashdot , : dashdotdot ])) '  n   =   length ( styles )  y   =   cumsum ( randn ( 20 , n ), 1 )  plot ( y , line = ( 5 , styles ), label = map ( string , styles ))",
            "title": "Line styles"
        },
        {
            "location": "/examples/plotlyjs/#marker-types",
            "text": "markers   =   ( filter (( m -> begin  \n             m   in   Plots . supported_markers () \n         end ), Plots . _shape_keys )) '  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat (( reverse ( x )) ' , n , 1 )  scatter ( x , y , m = ( 8 , : auto ), lab = map ( string , markers ), bg =: linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))",
            "title": "Marker types"
        },
        {
            "location": "/examples/plotlyjs/#bar",
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))",
            "title": "Bar"
        },
        {
            "location": "/examples/plotlyjs/#histogram",
            "text": "histogram ( randn ( 1000 ), nbins = 20 )",
            "title": "Histogram"
        },
        {
            "location": "/examples/plotlyjs/#subplots",
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @layout ([ a { 0.1 h }; b   [ c ; d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [ : line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )",
            "title": "Subplots"
        },
        {
            "location": "/examples/plotlyjs/#adding-to-subplots",
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [ : grays   : blues   : heat   : lightrainbow ], bg_inside = [ : orange   : pink   : darkblue   : black ])",
            "title": "Adding to subplots"
        },
        {
            "location": "/examples/plotlyjs/#openhighlowclose",
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )",
            "title": "Open/High/Low/Close"
        },
        {
            "location": "/examples/plotlyjs/#annotations",
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( \"this is #3\" , : left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( \"this is #5\" , 16 , : red , : center )),( 10 , y [ 10 ], text ( \"this is #10\" , : right , 20 , \"courier\" ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 , : orange ), series_annotations = [ \"series\" , \"annotations\" , \"map\" , \"to\" , \"series\" , text ( \"data\" , : green )])",
            "title": "Annotations"
        },
        {
            "location": "/examples/plotlyjs/#custom-markers",
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 , : dash , : lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg =: pink , fg =: darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )",
            "title": "Custom Markers"
        },
        {
            "location": "/examples/plotlyjs/#contours",
            "text": "Any value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.  x   =   1 : 0.5 : 20  y   =   1 : 0.5 : 10  f ( x , y )   =   begin  \n         ( 3 x   +   y   ^   2 )   *   abs ( sin ( x )   +   cos ( y )) \n     end  X   =   repmat ( x ' , length ( y ), 1 )  Y   =   repmat ( y , 1 , length ( x ))  Z   =   map ( f , X , Y )  p1   =   contour ( x , y , f , fill = true )  p2   =   contour ( x , y , Z )  plot ( p1 , p2 )",
            "title": "Contours"
        },
        {
            "location": "/examples/plotlyjs/#pie",
            "text": "x   =   [ \"Nerds\" , \"Hackers\" , \"Scientists\" ]  y   =   [ 0.4 , 0.35 , 0.25 ]  pie ( x , y , title = \"The Julia Community\" , l = 0.5 )",
            "title": "Pie"
        },
        {
            "location": "/examples/plotlyjs/#3d",
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 , : blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )",
            "title": "3D"
        },
        {
            "location": "/examples/plotlyjs/#groups-and-subplots",
            "text": "group   =   rand ( map (( i -> begin  \n                     \"group  $ ( i ) \" \n                 end ), 1 : 4 ), 100 )  plot ( rand ( 100 ), layout = @layout ([ a   b ; c ]), group = group , linetype = [ : bar   : scatter   : steppre ])",
            "title": "Groups and Subplots"
        },
        {
            "location": "/examples/plotlyjs/#heatmap-categorical-axes-and-aspect_ratio",
            "text": "xs   =   [ string ( \"x\" , i )   for   i   =   1 : 10 ]  ys   =   [ string ( \"y\" , i )   for   i   =   1 : 4 ]  z   =   float (( 1 : 4 )   *   ( 1 : 10 ) ' )  heatmap ( xs , ys , z , aspect_ratio = 1 )",
            "title": "Heatmap, categorical axes, and aspect_ratio"
        },
        {
            "location": "/examples/plotlyjs/#layouts-margins-label-rotation-title-location",
            "text": "plot ( rand ( 100 , 6 ), layout = @layout ([ a   b ; c ]), title = [ \"A\"   \"B\"   \"C\" ], title_location =: left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )     Supported arguments:  annotations ,  aspect_ratio ,  background_color ,  background_color_inside ,  background_color_legend ,  background_color_outside ,  background_color_subplot ,  bar_width ,  bins ,  bottom_margin ,  clims ,  color_palette ,  colorbar ,  colorbar_title ,  discrete_values ,  fill_z ,  fillalpha ,  fillcolor ,  fillrange ,  flip ,  foreground_color ,  foreground_color_border ,  foreground_color_guide ,  foreground_color_legend ,  foreground_color_subplot ,  foreground_color_text ,  foreground_color_title ,  grid ,  group ,  guide ,  guidefont ,  hover ,  html_output_format ,  inset_subplots ,  label ,  layout ,  left_margin ,  legend ,  legendfont ,  levels ,  lims ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  link ,  margin ,  marker_z ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokestyle ,  markerstrokewidth ,  normalize ,  orientation ,  polar ,  primary ,  projection ,  quiver ,  ribbon ,  right_margin ,  rotation ,  scale ,  series_annotations ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  smooth ,  subplot ,  subplot_index ,  tickfont ,  ticks ,  title ,  title_location ,  titlefont ,  top_margin ,  weights ,  window_title ,  x ,  xdiscrete_values ,  xerror ,  xflip ,  xforeground_color_border ,  xforeground_color_guide ,  xforeground_color_text ,  xguide ,  xguidefont ,  xlims ,  xlink ,  xrotation ,  xscale ,  xtickfont ,  xticks ,  y ,  ydiscrete_values ,  yerror ,  yflip ,  yforeground_color_border ,  yforeground_color_guide ,  yforeground_color_text ,  yguide ,  yguidefont ,  ylims ,  ylink ,  yrotation ,  yscale ,  ytickfont ,  yticks ,  z ,  zdiscrete_values ,  zflip ,  zforeground_color_border ,  zforeground_color_guide ,  zforeground_color_text ,  zguide ,  zguidefont ,  zlims ,  zlink ,  zrotation ,  zscale ,  ztickfont ,  zticks  Supported values for linetype:  :bar ,  :contour ,  :heatmap ,  :path ,  :path3d ,  :pie ,  :scatter ,  :scatter3d ,  :scattergl ,  :shape ,  :surface ,  :wireframe  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dot ,  :solid  Supported values for marker:  :auto ,  :circle ,  :cross ,  :diamond ,  :dtriangle ,  :hexagon ,  :hline ,  :none ,  :octagon ,  :pentagon ,  :rect ,  :utriangle ,  :vline ,  :xcross \n(Automatically generated: 2017-05-31T15:24:42.231)",
            "title": "Layouts, margins, label rotation, title location"
        },
        {
            "location": "/examples/pgfplots/",
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\npgfplots\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n->\nbegin\n\n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,\n:\norange\n))\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\n\"XLABEL\"\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,\n:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,\n:\ndash\n,\n0.6\n,[\n:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\n\"TITLE\"\n)\n\n\nyaxis!\n(\n\"YLABEL\"\n,\n:\nlog10\n)\n\n\n\n\n\n\n\n\nExtra LaTeX packages\n\n\nYou can add LaTeX formating with support for additional LaTeX packages with \nLaTeXStrings.jl\n and \nPGFPlots.pushPGFPlotsPreamble\n. For example, if we add the package \namssymb\n, we can get Blackboard bold symbols with the \n\\mathbb\n control sequence:\n\n\nusing\n \nLaTeXStrings\n\n\nPGFPlots\n.\npushPGFPlotsPreamble\n(\n\"\n\\\\\nusepackage{amssymb}\"\n)\n\n\nylabel!\n(\nL\n\"$\\mathbb E[f(x)]$\"\n)\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[\n:\nblack\n \n:\norange\n],\nline\n=\n(\n:\ndot\n,\n4\n),\nmarker\n=\n([\n:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,\n:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,\n:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=:\norange\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[\n:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \nsetdiff\n(\nPlots\n.\nsupported_styles\n(),[\n:\nauto\n])\n'\n\n\nplot\n(\ncumsum\n(\nrandn\n(\n20\n,\nlength\n(\nstyles\n)),\n1\n),\nstyle\n=:\nauto\n,\nlabel\n=\nmap\n(\nstring\n,\nstyles\n),\nw\n=\n5\n)\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \nsetdiff\n(\nPlots\n.\nsupported_markers\n(),[\n:\nnone\n,\n:\nauto\n,\nShape\n])\n'\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n(\nreverse\n(\nx\n)\n'\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,\n:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@layout\n([\na\n{\n0.1\nh\n};\nb\n \n[\nc\n;\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[\n:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[\n:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[\n:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\n\"this is #3\"\n,\n:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\n\"this is #5\"\n,\n16\n,\n:\nred\n,\n:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\n\"this is #10\"\n,\n:\nright\n,\n20\n,\n\"courier\"\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,\n:\norange\n),\nseries_annotations\n=\n[\n\"series\"\n,\n\"annotations\"\n,\n\"map\"\n,\n\"to\"\n,\n\"series\"\n,\ntext\n(\n\"data\"\n,\n:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,\n:\ndash\n,\n:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=:\npink\n,\nfg\n=:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,\n:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nDataFrames\n\n\nPlot using DataFrame column symbols.\n\n\nimport\n \nRDatasets\n\n\niris\n \n=\n \nRDatasets\n.\ndataset\n(\n\"datasets\"\n,\n\"iris\"\n)\n\n\nscatter\n(\niris\n,\n:\nSepalLength\n,\n:\nSepalWidth\n,\ngroup\n=:\nSpecies\n,\ntitle\n=\n\"My awesome plot\"\n,\nxlabel\n=\n\"Length\"\n,\nylabel\n=\n\"Width\"\n,\nmarker\n=\n(\n0.5\n,[\n:+\n \n:\nh\n \n:\nstar7\n],\n12\n),\nbg\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n))\n\n\n\n\n\n\n\n\nPolar Plots\n\n\n\u0398\n \n=\n \nlinspace\n(\n0\n,\n1.5\n\u03c0\n,\n100\n)\n\n\nr\n \n=\n \nabs\n(\n0.1\n \n*\n \nrandn\n(\n100\n)\n \n+\n \nsin\n(\n3\n\u0398\n))\n\n\nplot\n(\n\u0398\n,\nr\n,\nproj\n=:\npolar\n,\nm\n=\n2\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\n\"A\"\n \n\"B\"\n \n\"C\"\n],\ntitle_location\n=:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \naspect_ratio\n, \nbackground_color\n, \nbackground_color_inside\n, \nbins\n, \ncolor_palette\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nforeground_color\n, \ngrid\n, \ngroup\n, \nguidefont\n, \nlabel\n, \nlayout\n, \nlegend\n, \nlegendfont\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokewidth\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \ntickfont\n, \ntitle\n, \nx\n, \nxflip\n, \nxguide\n, \nxlims\n, \nxrotation\n, \nxscale\n, \nxticks\n, \ny\n, \nyflip\n, \nyguide\n, \nylims\n, \nyrotation\n, \nyscale\n, \nyticks\n, \nz\n, \nzflip\n, \nzguide\n, \nzlims\n, \nzrotation\n, \nzscale\n, \nzticks\n\n\nSupported values for axis: \n:auto\n, \n:left\n\n\nSupported values for linetype: \n:contour\n, \n:histogram2d\n, \n:path\n, \n:path3d\n, \n:scatter\n, \n:stepmid\n, \n:steppost\n, \n:steppre\n, \n:xsticks\n, \n:ysticks\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dashdotdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:auto\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:circle\n, \n:none\n, \n:pentagon\n, \n:rect\n, \n:star5\n, \n:utriangle\n, \n:xcross\n\n\nIs \nsubplot\n/\nsubplot!\n supported? No\n\n\n\n\n(Automatically generated: 2016-06-09T17:39:13)",
            "title": "PGFPlots"
        },
        {
            "location": "/examples/pgfplots/#initialize",
            "text": "using   Plots  pgfplots ()",
            "title": "Initialize"
        },
        {
            "location": "/examples/pgfplots/#lines",
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )",
            "title": "Lines"
        },
        {
            "location": "/examples/pgfplots/#parametric-plots",
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x -> begin \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 , : orange ))",
            "title": "Parametric plots"
        },
        {
            "location": "/examples/pgfplots/#global",
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( \"XLABEL\" ,( - 5 , 30 ), 0 : 2 : 20 , : flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 , : dash , 0.6 ,[ : lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( \"TITLE\" )  yaxis! ( \"YLABEL\" , : log10 )",
            "title": "Global"
        },
        {
            "location": "/examples/pgfplots/#extra-latex-packages",
            "text": "You can add LaTeX formating with support for additional LaTeX packages with  LaTeXStrings.jl  and  PGFPlots.pushPGFPlotsPreamble . For example, if we add the package  amssymb , we can get Blackboard bold symbols with the  \\mathbb  control sequence:  using   LaTeXStrings  PGFPlots . pushPGFPlotsPreamble ( \" \\\\ usepackage{amssymb}\" )  ylabel! ( L \"$\\mathbb E[f(x)]$\" )",
            "title": "Extra LaTeX packages"
        },
        {
            "location": "/examples/pgfplots/#arguments",
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [ : black   : orange ], line = ( : dot , 4 ), marker = ([ : hex   : d ], 12 , 0.8 , stroke ( 3 , : gray )))",
            "title": "Arguments"
        },
        {
            "location": "/examples/pgfplots/#build-plot-in-pieces",
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 , : green ))",
            "title": "Build plot in pieces"
        },
        {
            "location": "/examples/pgfplots/#line-types",
            "text": "linetypes   =   [ : path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )",
            "title": "Line types"
        },
        {
            "location": "/examples/pgfplots/#line-styles",
            "text": "styles   =   setdiff ( Plots . supported_styles (),[ : auto ]) '  plot ( cumsum ( randn ( 20 , length ( styles )), 1 ), style =: auto , label = map ( string , styles ), w = 5 )",
            "title": "Line styles"
        },
        {
            "location": "/examples/pgfplots/#marker-types",
            "text": "markers   =   setdiff ( Plots . supported_markers (),[ : none , : auto , Shape ]) '  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat ( reverse ( x ) ' , n , 1 )  scatter ( x , y , m = ( 8 , : auto ), lab = map ( string , markers ), bg =: linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))",
            "title": "Marker types"
        },
        {
            "location": "/examples/pgfplots/#bar",
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))",
            "title": "Bar"
        },
        {
            "location": "/examples/pgfplots/#histogram",
            "text": "histogram ( randn ( 1000 ), nbins = 20 )",
            "title": "Histogram"
        },
        {
            "location": "/examples/pgfplots/#subplots",
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @layout ([ a { 0.1 h }; b   [ c ; d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [ : line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )",
            "title": "Subplots"
        },
        {
            "location": "/examples/pgfplots/#adding-to-subplots",
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [ : grays   : blues   : heat   : lightrainbow ], bg_inside = [ : orange   : pink   : darkblue   : black ])",
            "title": "Adding to subplots"
        },
        {
            "location": "/examples/pgfplots/#openhighlowclose",
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )",
            "title": "Open/High/Low/Close"
        },
        {
            "location": "/examples/pgfplots/#annotations",
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( \"this is #3\" , : left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( \"this is #5\" , 16 , : red , : center )),( 10 , y [ 10 ], text ( \"this is #10\" , : right , 20 , \"courier\" ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 , : orange ), series_annotations = [ \"series\" , \"annotations\" , \"map\" , \"to\" , \"series\" , text ( \"data\" , : green )])",
            "title": "Annotations"
        },
        {
            "location": "/examples/pgfplots/#custom-markers",
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 , : dash , : lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg =: pink , fg =: darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )",
            "title": "Custom Markers"
        },
        {
            "location": "/examples/pgfplots/#3d",
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 , : blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )",
            "title": "3D"
        },
        {
            "location": "/examples/pgfplots/#dataframes",
            "text": "Plot using DataFrame column symbols.  import   RDatasets  iris   =   RDatasets . dataset ( \"datasets\" , \"iris\" )  scatter ( iris , : SepalLength , : SepalWidth , group =: Species , title = \"My awesome plot\" , xlabel = \"Length\" , ylabel = \"Width\" , marker = ( 0.5 ,[ :+   : h   : star7 ], 12 ), bg = RGB ( 0.2 , 0.2 , 0.2 ))",
            "title": "DataFrames"
        },
        {
            "location": "/examples/pgfplots/#polar-plots",
            "text": "\u0398   =   linspace ( 0 , 1.5 \u03c0 , 100 )  r   =   abs ( 0.1   *   randn ( 100 )   +   sin ( 3 \u0398 ))  plot ( \u0398 , r , proj =: polar , m = 2 )",
            "title": "Polar Plots"
        },
        {
            "location": "/examples/pgfplots/#layouts-margins-label-rotation-title-location",
            "text": "plot ( rand ( 100 , 6 ), layout = @layout ([ a   b ; c ]), title = [ \"A\"   \"B\"   \"C\" ], title_location =: left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )     Supported arguments:  aspect_ratio ,  background_color ,  background_color_inside ,  bins ,  color_palette ,  fillalpha ,  fillcolor ,  fillrange ,  foreground_color ,  grid ,  group ,  guidefont ,  label ,  layout ,  legend ,  legendfont ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokewidth ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  tickfont ,  title ,  x ,  xflip ,  xguide ,  xlims ,  xrotation ,  xscale ,  xticks ,  y ,  yflip ,  yguide ,  ylims ,  yrotation ,  yscale ,  yticks ,  z ,  zflip ,  zguide ,  zlims ,  zrotation ,  zscale ,  zticks  Supported values for axis:  :auto ,  :left  Supported values for linetype:  :contour ,  :histogram2d ,  :path ,  :path3d ,  :scatter ,  :stepmid ,  :steppost ,  :steppre ,  :xsticks ,  :ysticks  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dashdotdot ,  :dot ,  :solid  Supported values for marker:  :auto ,  :cross ,  :diamond ,  :dtriangle ,  :circle ,  :none ,  :pentagon ,  :rect ,  :star5 ,  :utriangle ,  :xcross  Is  subplot / subplot!  supported? No   (Automatically generated: 2016-06-09T17:39:13)",
            "title": "Layouts, margins, label rotation, title location"
        },
        {
            "location": "/examples/unicodeplots/",
            "text": "Examples for backend: unicodeplots\n\n\nInitialize\n\n\nusing\n \nPlots\n\n\nunicodeplots\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n->\nbegin\n  \n# /Users/tom/.julia/v0.4/Plots/docs/example_generation.jl, line 50:\n\n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,\n:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\n\"lines\"\n,\nw\n=\n3\n,\npalette\n=:\ngrays\n,\nfill\n=\n(\n0.5\n,\n:\nauto\n))\n\n\nscatter!\n(\ny\n,\nz\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(\n10\n,\n:\nheat\n),\nlab\n=\n\"grad\"\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\nplot\n(\nrand\n(\n20\n,\n3\n),\nxaxis\n=\n(\n\"XLABEL\"\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,\n:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\ntitle!\n(\n\"TITLE\"\n)\n\n\nyaxis!\n(\n\"YLABEL\"\n,\n:\nlog10\n)\n\n\n\n\n\n\n\n\nTwo-axis\n\n\nUse the \naxis\n arguments.\n\n\nNote: Currently only supported with Qwt and PyPlot\n\n\nplot\n(\nVector\n[\nrandn\n(\n100\n),\nrandn\n(\n100\n)\n \n*\n \n100\n],\naxis\n=\n[\n:\nl\n \n:\nr\n],\nylabel\n=\n\"LEFT\"\n,\nyrightlabel\n=\n\"RIGHT\"\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nplot\n(\nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)],\nmarker\n=\n(\n:\ncircle\n,\n8\n),\nline\n=\n(\n:\ndot\n,\n3\n,[\n:\nblack\n \n:\norange\n]))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,\n:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=:\norange\n)\n\n\n\n\n\n\n\n\nLine types\n\n\ntypes\n \n=\n \nintersect\n(\nsupported_types\n(),[\n:\nline\n,\n:\npath\n,\n:\nsteppre\n,\n:\nsteppost\n,\n:\nsticks\n,\n:\nscatter\n])\n'\n\n\nn\n \n=\n \nlength\n(\ntypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\ntypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\ntypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \nsetdiff\n(\nPlots\n.\nsupported_styles\n(),[\n:\nauto\n])\n'\n\n\nplot\n(\ncumsum\n(\nrandn\n(\n20\n,\nlength\n(\nstyles\n)),\n1\n),\nstyle\n=:\nauto\n,\nlabel\n=\nmap\n(\nstring\n,\nstyles\n),\nw\n=\n5\n)\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \nsetdiff\n(\nPlots\n.\nsupported_markers\n(),[\n:\nnone\n,\n:\nauto\n,\nShape\n])\n'\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n(\nreverse\n(\nx\n)\n'\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,\n:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=:\nlinen\n)\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n999\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n50\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nsubplot and subplot! are distinct commands which create many plots and add series to them in a circular fashion.\n  You can define the layout with keyword params... either set the number of plots \nn\n (and optionally number of rows \nnr\n or\n  number of columns \nnc\n), or you can set the layout directly with \nlayout\n.\n\n\nsubplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\n[\n1\n,\n1\n,\n3\n],\nt\n=\n[\n:\nline\n \n:\nhist\n \n:\nscatter\n \n:\nstep\n \n:\nbar\n],\nnbins\n=\n10\n,\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nsubplot\n(\nfakedata\n(\n100\n,\n10\n),\nn\n=\n4\n,\npalette\n=\n[\n:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg\n=\n[\n:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsubplot!\n(\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nplot\n(\n0.1\n:\n0.2\n:\n0.9\n,\n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n,\nl\n=\n(\n3\n,\n:\ndash\n,\n:\nlightblue\n),\nm\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=:\npink\n,\nfg\n=:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \ngroup\n, \nlabel\n, \nlegend\n, \nlinestyle\n, \nlinetype\n, \nmarkershape\n, \nnbins\n, \nshow\n, \nsize\n, \ntitle\n, \nwindowtitle\n, \nx\n, \nxlabel\n, \nxlims\n, \ny\n, \nylabel\n, \nylims\n\n\nSupported values for axis: \n:auto\n, \n:left\n\n\nSupported values for linetype: \n:bar\n, \n:heatmap\n, \n:hexbin\n, \n:hist\n, \n:hline\n, \n:line\n, \n:none\n, \n:path\n, \n:scatter\n, \n:steppost\n, \n:sticks\n, \n:vline\n\n\nSupported values for linestyle: \n:auto\n, \n:solid\n\n\nSupported values for marker: \n:auto\n, \n:circle\n, \n:none\n\n\nIs \nsubplot\n/\nsubplot!\n supported? Yes\n\n\n\n\n(Automatically generated: 2015-10-18T00:07:46)",
            "title": "UnicodePlots"
        },
        {
            "location": "/examples/unicodeplots/#examples-for-backend-unicodeplots",
            "text": "",
            "title": "Examples for backend: unicodeplots"
        },
        {
            "location": "/examples/unicodeplots/#initialize",
            "text": "using   Plots  unicodeplots ()",
            "title": "Initialize"
        },
        {
            "location": "/examples/unicodeplots/#lines",
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )",
            "title": "Lines"
        },
        {
            "location": "/examples/unicodeplots/#parametric-plots",
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x -> begin    # /Users/tom/.julia/v0.4/Plots/docs/example_generation.jl, line 50: \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 , : orange ))",
            "title": "Parametric plots"
        },
        {
            "location": "/examples/unicodeplots/#colors",
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = \"lines\" , w = 3 , palette =: grays , fill = ( 0.5 , : auto ))  scatter! ( y , z = abs ( y   -   0.5 ), m = ( 10 , : heat ), lab = \"grad\" )",
            "title": "Colors"
        },
        {
            "location": "/examples/unicodeplots/#global",
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  plot ( rand ( 20 , 3 ), xaxis = ( \"XLABEL\" ,( - 5 , 30 ), 0 : 2 : 20 , : flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  title! ( \"TITLE\" )  yaxis! ( \"YLABEL\" , : log10 )",
            "title": "Global"
        },
        {
            "location": "/examples/unicodeplots/#two-axis",
            "text": "Use the  axis  arguments.  Note: Currently only supported with Qwt and PyPlot  plot ( Vector [ randn ( 100 ), randn ( 100 )   *   100 ], axis = [ : l   : r ], ylabel = \"LEFT\" , yrightlabel = \"RIGHT\" )",
            "title": "Two-axis"
        },
        {
            "location": "/examples/unicodeplots/#arguments",
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  plot ( Vector [ rand ( 10 ), rand ( 20 )], marker = ( : circle , 8 ), line = ( : dot , 3 ,[ : black   : orange ]))",
            "title": "Arguments"
        },
        {
            "location": "/examples/unicodeplots/#build-plot-in-pieces",
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 , : green ))",
            "title": "Build plot in pieces"
        },
        {
            "location": "/examples/unicodeplots/#line-types",
            "text": "types   =   intersect ( supported_types (),[ : line , : path , : steppre , : steppost , : sticks , : scatter ]) '  n   =   length ( types )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( types , 3 ), lab = map ( string , types ), ms = 15 )",
            "title": "Line types"
        },
        {
            "location": "/examples/unicodeplots/#line-styles",
            "text": "styles   =   setdiff ( Plots . supported_styles (),[ : auto ]) '  plot ( cumsum ( randn ( 20 , length ( styles )), 1 ), style =: auto , label = map ( string , styles ), w = 5 )",
            "title": "Line styles"
        },
        {
            "location": "/examples/unicodeplots/#marker-types",
            "text": "markers   =   setdiff ( Plots . supported_markers (),[ : none , : auto , Shape ]) '  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat ( reverse ( x ) ' , n , 1 )  scatter ( x , y , m = ( 8 , : auto ), lab = map ( string , markers ), bg =: linen )",
            "title": "Marker types"
        },
        {
            "location": "/examples/unicodeplots/#bar",
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 999 ))",
            "title": "Bar"
        },
        {
            "location": "/examples/unicodeplots/#histogram",
            "text": "histogram ( randn ( 1000 ), nbins = 50 )",
            "title": "Histogram"
        },
        {
            "location": "/examples/unicodeplots/#subplots",
            "text": "subplot and subplot! are distinct commands which create many plots and add series to them in a circular fashion.\n  You can define the layout with keyword params... either set the number of plots  n  (and optionally number of rows  nr  or\n  number of columns  nc ), or you can set the layout directly with  layout .  subplot ( randn ( 100 , 5 ), layout = [ 1 , 1 , 3 ], t = [ : line   : hist   : scatter   : step   : bar ], nbins = 10 , leg = false )",
            "title": "Subplots"
        },
        {
            "location": "/examples/unicodeplots/#adding-to-subplots",
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  subplot ( fakedata ( 100 , 10 ), n = 4 , palette = [ : grays   : blues   : heat   : lightrainbow ], bg = [ : orange   : pink   : darkblue   : black ])",
            "title": "Adding to subplots"
        },
        {
            "location": "/examples/unicodeplots/#custom-markers",
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  plot ( 0.1 : 0.2 : 0.9 , 0.7   *   rand ( 5 )   +   0.15 , l = ( 3 , : dash , : lightblue ), m = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg =: pink , fg =: darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )     Supported arguments:  group ,  label ,  legend ,  linestyle ,  linetype ,  markershape ,  nbins ,  show ,  size ,  title ,  windowtitle ,  x ,  xlabel ,  xlims ,  y ,  ylabel ,  ylims  Supported values for axis:  :auto ,  :left  Supported values for linetype:  :bar ,  :heatmap ,  :hexbin ,  :hist ,  :hline ,  :line ,  :none ,  :path ,  :scatter ,  :steppost ,  :sticks ,  :vline  Supported values for linestyle:  :auto ,  :solid  Supported values for marker:  :auto ,  :circle ,  :none  Is  subplot / subplot!  supported? Yes   (Automatically generated: 2015-10-18T00:07:46)",
            "title": "Custom Markers"
        },
        {
            "location": "/examples/inspectdr/",
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\ninspectdr\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n->\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,\n:\norange\n))\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\n\"XLABEL\"\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,\n:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,\n:\ndash\n,\n0.6\n,[\n:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\n\"TITLE\"\n)\n\n\nyaxis!\n(\n\"YLABEL\"\n,\n:\nlog10\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[\n:\nblack\n \n:\norange\n],\nline\n=\n(\n:\ndot\n,\n4\n),\nmarker\n=\n([\n:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,\n:\ngray\n)))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=:\norange\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[\n:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \n(\nfilter\n((\ns\n->\nbegin\n \n            \ns\n \nin\n \nPlots\n.\nsupported_styles\n()\n\n        \nend\n),[\n:\nsolid\n,\n:\ndash\n,\n:\ndot\n,\n:\ndashdot\n,\n:\ndashdotdot\n]))\n'\n\n\nn\n \n=\n \nlength\n(\nstyles\n)\n\n\ny\n \n=\n \ncumsum\n(\nrandn\n(\n20\n,\nn\n),\n1\n)\n\n\nplot\n(\ny\n,\nline\n=\n(\n5\n,\nstyles\n),\nlabel\n=\nmap\n(\nstring\n,\nstyles\n))\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \n(\nfilter\n((\nm\n->\nbegin\n \n            \nm\n \nin\n \nPlots\n.\nsupported_markers\n()\n\n        \nend\n),\nPlots\n.\n_shape_keys\n))\n'\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n((\nreverse\n(\nx\n))\n'\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,\n:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@layout\n([\na\n{\n0.1\nh\n};\nb\n \n[\nc\n;\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[\n:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[\n:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[\n:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\n\"this is #3\"\n,\n:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\n\"this is #5\"\n,\n16\n,\n:\nred\n,\n:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\n\"this is #10\"\n,\n:\nright\n,\n20\n,\n\"courier\"\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,\n:\norange\n),\nseries_annotations\n=\n[\n\"series\"\n,\n\"annotations\"\n,\n\"map\"\n,\n\"to\"\n,\n\"series\"\n,\ntext\n(\n\"data\"\n,\n:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,\n:\ndash\n,\n:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=:\npink\n,\nfg\n=:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nGroups and Subplots\n\n\ngroup\n \n=\n \nrand\n(\nmap\n((\ni\n->\nbegin\n \n                    \n\"group \n$\n(\ni\n)\n\"\n\n                \nend\n),\n1\n:\n4\n),\n100\n)\n\n\nplot\n(\nrand\n(\n100\n),\nlayout\n=\n@layout\n([\na\n \nb\n;\nc\n]),\ngroup\n=\ngroup\n,\nlinetype\n=\n[\n:\nbar\n \n:\nscatter\n \n:\nsteppre\n])\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \nannotations\n, \nbackground_color\n, \nbackground_color_inside\n, \nbackground_color_legend\n, \nbackground_color_outside\n, \nbackground_color_subplot\n, \nbottom_margin\n, \ncolor_palette\n, \ndiscrete_values\n, \ndpi\n, \nfillalpha\n, \nfillcolor\n, \nforeground_color\n, \nforeground_color_axis\n, \nforeground_color_border\n, \nforeground_color_grid\n, \nforeground_color_guide\n, \nforeground_color_legend\n, \nforeground_color_subplot\n, \nforeground_color_text\n, \nforeground_color_title\n, \ngrid\n, \ngroup\n, \nguide\n, \nguidefont\n, \nhtml_output_format\n, \nlabel\n, \nlayout\n, \nleft_margin\n, \nlegend\n, \nlegendfont\n, \nlims\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nlink\n, \nmargin\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokestyle\n, \nmarkerstrokewidth\n, \nmatch_dimensions\n, \noverwrite_figure\n, \npolar\n, \nprimary\n, \nprojection\n, \nright_margin\n, \nscale\n, \nseries_annotations\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \nsmooth\n, \nsubplot\n, \nsubplot_index\n, \ntickfont\n, \ntitle\n, \ntitle_location\n, \ntitlefont\n, \ntop_margin\n, \nwindow_title\n, \nx\n, \nxdiscrete_values\n, \nxerror\n, \nxforeground_color_axis\n, \nxforeground_color_border\n, \nxforeground_color_guide\n, \nxforeground_color_text\n, \nxguide\n, \nxguidefont\n, \nxlims\n, \nxlink\n, \nxscale\n, \nxtickfont\n, \ny\n, \nydiscrete_values\n, \nyerror\n, \nyforeground_color_axis\n, \nyforeground_color_border\n, \nyforeground_color_guide\n, \nyforeground_color_text\n, \nyguide\n, \nyguidefont\n, \nylims\n, \nylink\n, \nyscale\n, \nytickfont\n, \nz\n, \nzdiscrete_values\n, \nzforeground_color_axis\n, \nzforeground_color_border\n, \nzforeground_color_guide\n, \nzforeground_color_text\n, \nzguide\n, \nzguidefont\n, \nzlims\n, \nzlink\n, \nzscale\n, \nztickfont\n\n\nSupported values for linetype: \n:path\n, \n:scatter\n, \n:shape\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:+\n, \n:auto\n, \n:circle\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:heptagon\n, \n:hexagon\n, \n:hline\n, \n:ltriangle\n, \n:none\n, \n:octagon\n, \n:pentagon\n, \n:rect\n, \n:rtriangle\n, \n:star4\n, \n:star5\n, \n:star6\n, \n:star7\n, \n:star8\n, \n:utriangle\n, \n:vline\n, \n:x\n, \n:xcross\n\n(Automatically generated: 2017-05-31T16:38:34.425)",
            "title": "InspectDR"
        },
        {
            "location": "/examples/inspectdr/#initialize",
            "text": "using   Plots  inspectdr ()",
            "title": "Initialize"
        },
        {
            "location": "/examples/inspectdr/#lines",
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )",
            "title": "Lines"
        },
        {
            "location": "/examples/inspectdr/#parametric-plots",
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x -> begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 , : orange ))",
            "title": "Parametric plots"
        },
        {
            "location": "/examples/inspectdr/#global",
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( \"XLABEL\" ,( - 5 , 30 ), 0 : 2 : 20 , : flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 , : dash , 0.6 ,[ : lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( \"TITLE\" )  yaxis! ( \"YLABEL\" , : log10 )",
            "title": "Global"
        },
        {
            "location": "/examples/inspectdr/#arguments",
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [ : black   : orange ], line = ( : dot , 4 ), marker = ([ : hex   : d ], 12 , 0.8 , stroke ( 3 , : gray )))",
            "title": "Arguments"
        },
        {
            "location": "/examples/inspectdr/#line-types",
            "text": "linetypes   =   [ : path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )",
            "title": "Line types"
        },
        {
            "location": "/examples/inspectdr/#line-styles",
            "text": "styles   =   ( filter (( s -> begin  \n             s   in   Plots . supported_styles () \n         end ),[ : solid , : dash , : dot , : dashdot , : dashdotdot ])) '  n   =   length ( styles )  y   =   cumsum ( randn ( 20 , n ), 1 )  plot ( y , line = ( 5 , styles ), label = map ( string , styles ))",
            "title": "Line styles"
        },
        {
            "location": "/examples/inspectdr/#marker-types",
            "text": "markers   =   ( filter (( m -> begin  \n             m   in   Plots . supported_markers () \n         end ), Plots . _shape_keys )) '  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat (( reverse ( x )) ' , n , 1 )  scatter ( x , y , m = ( 8 , : auto ), lab = map ( string , markers ), bg =: linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))",
            "title": "Marker types"
        },
        {
            "location": "/examples/inspectdr/#bar",
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))",
            "title": "Bar"
        },
        {
            "location": "/examples/inspectdr/#histogram",
            "text": "histogram ( randn ( 1000 ), nbins = 20 )",
            "title": "Histogram"
        },
        {
            "location": "/examples/inspectdr/#subplots",
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @layout ([ a { 0.1 h }; b   [ c ; d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [ : line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )",
            "title": "Subplots"
        },
        {
            "location": "/examples/inspectdr/#adding-to-subplots",
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [ : grays   : blues   : heat   : lightrainbow ], bg_inside = [ : orange   : pink   : darkblue   : black ])",
            "title": "Adding to subplots"
        },
        {
            "location": "/examples/inspectdr/#openhighlowclose",
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )",
            "title": "Open/High/Low/Close"
        },
        {
            "location": "/examples/inspectdr/#annotations",
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( \"this is #3\" , : left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( \"this is #5\" , 16 , : red , : center )),( 10 , y [ 10 ], text ( \"this is #10\" , : right , 20 , \"courier\" ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 , : orange ), series_annotations = [ \"series\" , \"annotations\" , \"map\" , \"to\" , \"series\" , text ( \"data\" , : green )])",
            "title": "Annotations"
        },
        {
            "location": "/examples/inspectdr/#custom-markers",
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 , : dash , : lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg =: pink , fg =: darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )",
            "title": "Custom Markers"
        },
        {
            "location": "/examples/inspectdr/#groups-and-subplots",
            "text": "group   =   rand ( map (( i -> begin  \n                     \"group  $ ( i ) \" \n                 end ), 1 : 4 ), 100 )  plot ( rand ( 100 ), layout = @layout ([ a   b ; c ]), group = group , linetype = [ : bar   : scatter   : steppre ])     Supported arguments:  annotations ,  background_color ,  background_color_inside ,  background_color_legend ,  background_color_outside ,  background_color_subplot ,  bottom_margin ,  color_palette ,  discrete_values ,  dpi ,  fillalpha ,  fillcolor ,  foreground_color ,  foreground_color_axis ,  foreground_color_border ,  foreground_color_grid ,  foreground_color_guide ,  foreground_color_legend ,  foreground_color_subplot ,  foreground_color_text ,  foreground_color_title ,  grid ,  group ,  guide ,  guidefont ,  html_output_format ,  label ,  layout ,  left_margin ,  legend ,  legendfont ,  lims ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  link ,  margin ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokestyle ,  markerstrokewidth ,  match_dimensions ,  overwrite_figure ,  polar ,  primary ,  projection ,  right_margin ,  scale ,  series_annotations ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  smooth ,  subplot ,  subplot_index ,  tickfont ,  title ,  title_location ,  titlefont ,  top_margin ,  window_title ,  x ,  xdiscrete_values ,  xerror ,  xforeground_color_axis ,  xforeground_color_border ,  xforeground_color_guide ,  xforeground_color_text ,  xguide ,  xguidefont ,  xlims ,  xlink ,  xscale ,  xtickfont ,  y ,  ydiscrete_values ,  yerror ,  yforeground_color_axis ,  yforeground_color_border ,  yforeground_color_guide ,  yforeground_color_text ,  yguide ,  yguidefont ,  ylims ,  ylink ,  yscale ,  ytickfont ,  z ,  zdiscrete_values ,  zforeground_color_axis ,  zforeground_color_border ,  zforeground_color_guide ,  zforeground_color_text ,  zguide ,  zguidefont ,  zlims ,  zlink ,  zscale ,  ztickfont  Supported values for linetype:  :path ,  :scatter ,  :shape  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dot ,  :solid  Supported values for marker:  :+ ,  :auto ,  :circle ,  :cross ,  :diamond ,  :dtriangle ,  :heptagon ,  :hexagon ,  :hline ,  :ltriangle ,  :none ,  :octagon ,  :pentagon ,  :rect ,  :rtriangle ,  :star4 ,  :star5 ,  :star6 ,  :star7 ,  :star8 ,  :utriangle ,  :vline ,  :x ,  :xcross \n(Automatically generated: 2017-05-31T16:38:34.425)",
            "title": "Groups and Subplots"
        }
    ]
}